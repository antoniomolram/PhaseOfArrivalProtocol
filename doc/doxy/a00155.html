<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: PostureTransition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PostureTransition Class Reference<br/>
<small>
[<a class="el" href="a00448.html">mobility - modules handling the mobility of the hosts</a>]</small>
</h1><!-- doxytag: class="PostureTransition" -->
<p>Class to provide spatial and temporal correlation in the posture selection process of the MoBAN mobility model. This class obtains and stores Markovian transition matrices. There is also the possibility to get a steady state vector. In this case, the closest transition matrix to the default Makov matrix is extracted which satisfies the given steady state vector. The class also receives the defined area types and time domains as well as given space-time domains during the initialization phase. During the simulation run, the class provide a functions to return the corresponding markov matrix for a given time and location. It will be used whenever a new posture is going to be selected.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00370_source.html">PostureTransition.h</a>&gt;</code></p>

<p><a href="a00725.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">CombinationType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of space-time combination.  <a href="a00046.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">tAreaBound</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of the area (space) boundary.  <a href="a00180.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">tAreaType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of area type.  <a href="a00181.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">tTimeBound</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of the time boundary.  <a href="a00192.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">tTimeDomainType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of time domain.  <a href="a00193.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">tTransMatrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of Markov transition matrix.  <a href="a00194.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a4b10c46a88e6be413c7395c06bf65380">PostureTransition</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a posture transition object. The parameter is the number of postures which is the dimension of all matrices.  <a href="#a4b10c46a88e6be413c7395c06bf65380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a2f02ecf5282c7bd2f124a814c9abaa47">addMatrix</a> (std::string, double **, bool)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receives a transition matrix and add to the list.  <a href="#a2f02ecf5282c7bd2f124a814c9abaa47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#ac5c424a8372a3d6f39ccc06c88d4249f">addSteadyState</a> (std::string, double *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receives a steady state vector, extracts the corresponding transition matrix considering the default matrix, and add to the list of given matrices.  <a href="#ac5c424a8372a3d6f39ccc06c88d4249f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a261ad915b2a9c7cdf7082660360190e4">addAreaType</a> (std::string)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a area type to the list with the given name and returns the index of this area type in the list.  <a href="#a261ad915b2a9c7cdf7082660360190e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a309ed6acf7eca6469f0ea0f06ee41780">setAreaBoundry</a> (int, <a class="el" href="a00062.html">Coord</a>, <a class="el" href="a00062.html">Coord</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the given boundary to the existing area type specified by the given ID .  <a href="#a309ed6acf7eca6469f0ea0f06ee41780"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a58c7924dfb8810ba37311217a7ba5c8d">addTimeDomain</a> (std::string)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a time domain to the list with the given name and returns the index of the this time domain in the list.  <a href="#a58c7924dfb8810ba37311217a7ba5c8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#ac26d34882db804ce0aa2a8081e526729">setTimeBoundry</a> (int, simtime_t_cref, simtime_t_cref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the given boundary to the existing time domain specified by the given ID .  <a href="#ac26d34882db804ce0aa2a8081e526729"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a5b4ab00961c0039aac63143d28e88272">addCombination</a> (std::string, std::string, std::string)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a space-time combination to the list.  <a href="#a5b4ab00961c0039aac63143d28e88272"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a93efe929bf92a744b9343730011579bf">getMatrix</a> (simtime_t_cref, <a class="el" href="a00062.html">Coord</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a time and location, and returns the corresponding Markov transition matrix.  <a href="#a93efe929bf92a744b9343730011579bf"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40b8581302bc59e9f3ee079b889d2eba"></a><!-- doxytag: member="PostureTransition::TransMatrix" ref="a40b8581302bc59e9f3ee079b889d2eba" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="a00194.html">PostureTransition::tTransMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a40b8581302bc59e9f3ee079b889d2eba">TransMatrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of Markov transition matrix. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9e0f2800e1fa2b681ed55c07eb8046"></a><!-- doxytag: member="PostureTransition::TransMatrixList" ref="a7c9e0f2800e1fa2b681ed55c07eb8046" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00194.html">TransMatrix</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a7c9e0f2800e1fa2b681ed55c07eb8046">TransMatrixList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for a list of Markov transition matrices. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefc213d43332c35fdb8ef1c665ef7ba3"></a><!-- doxytag: member="PostureTransition::AreaBound" ref="aefc213d43332c35fdb8ef1c665ef7ba3" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="a00180.html">PostureTransition::tAreaBound</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#aefc213d43332c35fdb8ef1c665ef7ba3">AreaBound</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of the area (space) boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f798df44704bf41b90d4bcfc87d0e4d"></a><!-- doxytag: member="PostureTransition::AreaType" ref="a7f798df44704bf41b90d4bcfc87d0e4d" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="a00181.html">PostureTransition::tAreaType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a7f798df44704bf41b90d4bcfc87d0e4d">AreaType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of area type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98b2ed7203b32614bd82d29079db59cc"></a><!-- doxytag: member="PostureTransition::AreaTypeList" ref="a98b2ed7203b32614bd82d29079db59cc" args="" -->
typedef std::vector&lt; <a class="el" href="a00181.html">AreaType</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a98b2ed7203b32614bd82d29079db59cc">AreaTypeList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for the list of area types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0f85ea329cfde097850b5582d3735d1"></a><!-- doxytag: member="PostureTransition::TimeBound" ref="af0f85ea329cfde097850b5582d3735d1" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="a00192.html">PostureTransition::tTimeBound</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#af0f85ea329cfde097850b5582d3735d1">TimeBound</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of the time boundary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b888102d88c7dbb3a1359f6f8019784"></a><!-- doxytag: member="PostureTransition::TimeDomainType" ref="a9b888102d88c7dbb3a1359f6f8019784" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="a00193.html">PostureTransition::tTimeDomainType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a9b888102d88c7dbb3a1359f6f8019784">TimeDomainType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of time domain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a867c3cd2530e28d6f2953508a700ffec"></a><!-- doxytag: member="PostureTransition::TimeDomainList" ref="a867c3cd2530e28d6f2953508a700ffec" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00193.html">TimeDomainType</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a867c3cd2530e28d6f2953508a700ffec">TimeDomainList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for the list of time domains. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03a03987992fffd49db8174cf6e83953"></a><!-- doxytag: member="PostureTransition::CombinationList" ref="a03a03987992fffd49db8174cf6e83953" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00046.html">CombinationType</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a03a03987992fffd49db8174cf6e83953">CombinationList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for the list of space-time combinations. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a3ddddcbf58ad8e1edd23cf8023c7b974">extractMatrixFromSteadyState</a> (double *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a steady state vector and return a matrix which is as close as posible to the default matrix and satisfies the given steady state.  <a href="#a3ddddcbf58ad8e1edd23cf8023c7b974"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#ad2663f9084d4a805296bc0939f28001c">findTimeDomain</a> (simtime_t_cref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a time and finds the ID of the containing time domain if there is. If not, return -1.  <a href="#ad2663f9084d4a805296bc0939f28001c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a299b33afdc27f467b3cdd472a397bb5a">findAreaType</a> (<a class="el" href="a00062.html">Coord</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a location and finds the ID of the containing area type if there is. If not, return -1.  <a href="#a299b33afdc27f467b3cdd472a397bb5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#abe806a2afdeb239694094c24446f699f">isMarkovian</a> (double **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a matrix can be a Markov transition matrix. All elements should be in the range [0,1] and elements of each column of the matrix should add up to 1.  <a href="#abe806a2afdeb239694094c24446f699f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a67a8cc00702db7106fc5b38447398856">isMarkovian</a> (double *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a vector can be the steady state of a Markov chain. All elements should be in the range [0,1] and the sum of elements should be 1.  <a href="#a67a8cc00702db7106fc5b38447398856"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#abe7336508b8864deeb66872425662587">multMatrix</a> (double **, double **, double **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies two matrices with dimension numPos*numPose .  <a href="#abe7336508b8864deeb66872425662587"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a10abfb612543bbc52f6a13a0e138d822">addMatrix</a> (double **, double **, double **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds two matrices with dimension numPos*numPose .  <a href="#a10abfb612543bbc52f6a13a0e138d822"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#af48e8ee3a857b2425a9f1fe6ded08841">subtractMatrix</a> (double **, double **, double **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtracts two matrices with dimension numPos*numPose .  <a href="#af48e8ee3a857b2425a9f1fe6ded08841"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a2781afe68489f9278e755429787b22ec">multVector</a> (double *, double **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a vector of size numPos with its transpose.  <a href="#a2781afe68489f9278e755429787b22ec"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88d4a9fb3d68fb6792ebade157067d73"></a><!-- doxytag: member="PostureTransition::numPos" ref="a88d4a9fb3d68fb6792ebade157067d73" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of postures. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae24e4f7a9dc7453d935b87669a0edf24"></a><!-- doxytag: member="PostureTransition::defaultMatrixID" ref="ae24e4f7a9dc7453d935b87669a0edf24" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#ae24e4f7a9dc7453d935b87669a0edf24">defaultMatrixID</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The index of the default (base) transition matrix. If no default is set, the first matrix is supposed as the default. Default matrix is used for the cases that a time or space domain does not lie in any given area types or time domains. It is also used for generating the transition matrix in the case that a steady state vector is given for a space-time domain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16d12fd657a13f5a43f5b9d1dd6fea7a"></a><!-- doxytag: member="PostureTransition::matrixList" ref="a16d12fd657a13f5a43f5b9d1dd6fea7a" args="" -->
<a class="el" href="a00155.html#a7c9e0f2800e1fa2b681ed55c07eb8046">TransMatrixList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a">matrixList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of all given transition matrices. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a438b1e6813a28c3b9b49ae4ecef1b937"></a><!-- doxytag: member="PostureTransition::areaTypeList" ref="a438b1e6813a28c3b9b49ae4ecef1b937" args="" -->
<a class="el" href="a00155.html#a98b2ed7203b32614bd82d29079db59cc">AreaTypeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937">areaTypeList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of all defined area types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0566260a55d34fde7d6e35103f95785a"></a><!-- doxytag: member="PostureTransition::timeDomainList" ref="a0566260a55d34fde7d6e35103f95785a" args="" -->
<a class="el" href="a00155.html#a867c3cd2530e28d6f2953508a700ffec">TimeDomainList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#a0566260a55d34fde7d6e35103f95785a">timeDomainList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of all defined time domains. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4afd59bcc62d7e198bebff13c873746"></a><!-- doxytag: member="PostureTransition::combinationList" ref="ab4afd59bcc62d7e198bebff13c873746" args="" -->
<a class="el" href="a00155.html#a03a03987992fffd49db8174cf6e83953">CombinationList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html#ab4afd59bcc62d7e198bebff13c873746">combinationList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of all given space-time combinations. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class to provide spatial and temporal correlation in the posture selection process of the MoBAN mobility model. This class obtains and stores Markovian transition matrices. There is also the possibility to get a steady state vector. In this case, the closest transition matrix to the default Makov matrix is extracted which satisfies the given steady state vector. The class also receives the defined area types and time domains as well as given space-time domains during the initialization phase. During the simulation run, the class provide a functions to return the corresponding markov matrix for a given time and location. It will be used whenever a new posture is going to be selected. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Majid Nabi </dd></dl>

<p>Definition at line <a class="el" href="a00370_source.html#l00061">61</a> of file <a class="el" href="a00370_source.html">PostureTransition.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4b10c46a88e6be413c7395c06bf65380"></a><!-- doxytag: member="PostureTransition::PostureTransition" ref="a4b10c46a88e6be413c7395c06bf65380" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostureTransition::PostureTransition </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPosture</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a posture transition object. The parameter is the number of postures which is the dimension of all matrices. </p>
<p>Constructor function of the class. It sets the value for t he number of posture. It also suppose the first given transition matrix as default. However, during parsing the xml configuration file, if a matrix has attribute type with value "default", it will be considered as the default (base) transition matrix. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00056">56</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00057"></a>00057   : <a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>(numPosture)
<a name="l00058"></a>00058   , <a class="code" href="a00155.html#ae24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first...">defaultMatrixID</a>(0)
<a name="l00059"></a>00059   , <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>()
<a name="l00060"></a>00060   , <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>()
<a name="l00061"></a>00061   , <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>()
<a name="l00062"></a>00062   , <a class="code" href="a00155.html#ab4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>()
<a name="l00063"></a>00063 { }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a261ad915b2a9c7cdf7082660360190e4"></a><!-- doxytag: member="PostureTransition::addAreaType" ref="a261ad915b2a9c7cdf7082660360190e4" args="(std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addAreaType </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a area type to the list with the given name and returns the index of this area type in the list. </p>
<p>Creates a new area type instance and adds it to the list. The boundaries of the area type is empty now. It will be filled later. The function returns the index of the new area type in the list as its output. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00153">153</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00113">areaTypeList</a>.</p>

<p>Referenced by <a class="el" href="a00363_source.html#l00514">MoBANCoordinator::readConfigurationFile()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00154"></a>00154 {
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="comment">//Check if the name is repetitive</span>
<a name="l00157"></a>00157   AreaTypeList::const_iterator areaIt;
<a name="l00158"></a>00158   <span class="keywordflow">for</span> (areaIt = <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.begin(); areaIt != <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.end(); areaIt++)
<a name="l00159"></a>00159   {
<a name="l00160"></a>00160     <span class="keywordflow">if</span> ((*areaIt)-&gt;name == name )
<a name="l00161"></a>00161     {
<a name="l00162"></a>00162       std::string str = <span class="stringliteral">&quot;There are multiple area types with the same name: &quot;</span> + name + <span class="stringliteral">&quot; in the configuration file!&quot;</span>;
<a name="l00163"></a>00163       opp_error (str.c_str());
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <a class="code" href="a00155.html#a7f798df44704bf41b90d4bcfc87d0e4d" title="Data type for one instance of area type.">AreaType</a>* area = <span class="keyword">new</span> <a class="code" href="a00155.html#a7f798df44704bf41b90d4bcfc87d0e4d" title="Data type for one instance of area type.">AreaType</a>;
<a name="l00168"></a>00168   area-&gt;name = name;
<a name="l00169"></a>00169   <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.push_back(area);
<a name="l00170"></a>00170   <span class="keywordflow">return</span> <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.size()-1;
<a name="l00171"></a>00171 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5b4ab00961c0039aac63143d28e88272"></a><!-- doxytag: member="PostureTransition::addCombination" ref="a5b4ab00961c0039aac63143d28e88272" args="(std::string, std::string, std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::addCombination </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>areaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>timeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>matrixName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a space-time combination to the list. </p>
<p>This function creates a new space-time combination instance and adds it to the combinations list. It checks if the given names for area type, time domain, and matrix are previously defined and exist in the corresponding lists. Note that at least area type or time domain should have been specified for a combination. Otherwise the combination is not meaningful. if for example a combination has no area type and just has specified time domain, it means that for the whole simulation area, it will be the same and the proper matrix is selected based on the time. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00230">230</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00113">areaTypeList</a>, <a class="el" href="a00370_source.html#l00148">combinationList</a>, <a class="el" href="a00370_source.html#l00091">matrixList</a>, and <a class="el" href="a00370_source.html#l00135">timeDomainList</a>.</p>

<p>Referenced by <a class="el" href="a00363_source.html#l00514">MoBANCoordinator::readConfigurationFile()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00231"></a>00231 {
<a name="l00232"></a>00232   <span class="keywordtype">int</span> thisID;
<a name="l00233"></a>00233   CombinationType* comb = <span class="keyword">new</span> CombinationType;
<a name="l00234"></a>00234   comb-&gt;areaID = -1;
<a name="l00235"></a>00235   comb-&gt;timeID = -1;
<a name="l00236"></a>00236   comb-&gt;matrixID = -1;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238   <span class="comment">// look for matching area type name.</span>
<a name="l00239"></a>00239   thisID = 0;
<a name="l00240"></a>00240   AreaTypeList::const_iterator areaIt;
<a name="l00241"></a>00241   <span class="keywordflow">for</span> (areaIt = <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.begin(); areaIt != <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.end(); areaIt++)
<a name="l00242"></a>00242   {
<a name="l00243"></a>00243     <span class="keywordflow">if</span> (areaName == (*areaIt)-&gt;name )
<a name="l00244"></a>00244     {
<a name="l00245"></a>00245       comb-&gt;areaID = thisID;
<a name="l00246"></a>00246       <span class="keywordflow">break</span>;
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248     ++thisID;
<a name="l00249"></a>00249   }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="comment">// in the input name is empty, it means that no area type is specified for this combination.</span>
<a name="l00252"></a>00252   <span class="keywordflow">if</span> (comb-&gt;areaID == -1 &amp;&amp; !areaName.empty())
<a name="l00253"></a>00253   {
<a name="l00254"></a>00254     std::string str = <span class="stringliteral">&quot;Undefined area type name is given in a combinations: &quot;</span> + areaName + <span class="stringliteral">&quot;, &quot;</span> + timeName + <span class="stringliteral">&quot;, &quot;</span> + matrixName;
<a name="l00255"></a>00255     opp_error (str.c_str());
<a name="l00256"></a>00256   }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="comment">// look for matching time domain name.</span>
<a name="l00260"></a>00260   thisID = 0;
<a name="l00261"></a>00261   TimeDomainList::const_iterator timeIt;
<a name="l00262"></a>00262   <span class="keywordflow">for</span> (timeIt = <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.begin(); timeIt != <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.end(); timeIt++)
<a name="l00263"></a>00263   {
<a name="l00264"></a>00264     <span class="keywordflow">if</span> (timeName == (*timeIt)-&gt;name )
<a name="l00265"></a>00265     {
<a name="l00266"></a>00266       comb-&gt;timeID = thisID;
<a name="l00267"></a>00267       <span class="keywordflow">break</span>;
<a name="l00268"></a>00268     }
<a name="l00269"></a>00269     ++thisID;
<a name="l00270"></a>00270   }
<a name="l00271"></a>00271   <span class="keywordflow">if</span> (comb-&gt;timeID == -1 &amp;&amp; !timeName.empty())
<a name="l00272"></a>00272   {
<a name="l00273"></a>00273     std::string str = <span class="stringliteral">&quot;Undefined time domain name is given in a combinations: &quot;</span> + areaName + <span class="stringliteral">&quot;, &quot;</span> + timeName + <span class="stringliteral">&quot;, &quot;</span> + matrixName;
<a name="l00274"></a>00274     opp_error (str.c_str());
<a name="l00275"></a>00275   }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="keywordflow">if</span> (comb-&gt;areaID == -1 &amp;&amp; comb-&gt;timeID == -1)
<a name="l00279"></a>00279     opp_error (<span class="stringliteral">&quot;Both area type and time domain is unspecified in a combination.&quot;</span> );
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   <span class="comment">// look for matching transition matrix name.</span>
<a name="l00282"></a>00282   thisID = 0;
<a name="l00283"></a>00283   TransMatrixList::const_iterator matrixIt;
<a name="l00284"></a>00284   <span class="keywordflow">for</span> (matrixIt = <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.begin(); matrixIt != <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.end(); matrixIt++)
<a name="l00285"></a>00285   {
<a name="l00286"></a>00286     <span class="keywordflow">if</span> (matrixName == (*matrixIt)-&gt;name )
<a name="l00287"></a>00287     {
<a name="l00288"></a>00288       comb-&gt;matrixID = thisID;
<a name="l00289"></a>00289       <span class="keywordflow">break</span>;
<a name="l00290"></a>00290     }
<a name="l00291"></a>00291     ++thisID;
<a name="l00292"></a>00292   }
<a name="l00293"></a>00293   <span class="keywordflow">if</span> (comb-&gt;matrixID == -1)
<a name="l00294"></a>00294     opp_error (<span class="stringliteral">&quot;Undefined matrix name is given in the combinations&quot;</span> );
<a name="l00295"></a>00295 
<a name="l00296"></a>00296   <a class="code" href="a00155.html#ab4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>.push_back(comb);
<a name="l00297"></a>00297 
<a name="l00298"></a>00298   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00299"></a>00299 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2f02ecf5282c7bd2f124a814c9abaa47"></a><!-- doxytag: member="PostureTransition::addMatrix" ref="a2f02ecf5282c7bd2f124a814c9abaa47" args="(std::string, double **, bool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addMatrix </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>thisDefault</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives a transition matrix and add to the list. </p>
<p>This function initiates a new instance of markov matrix with the given matrix. Note that it copies the matrix into the created matrix. The function first verifies if the given matrix can be a Markov transition matrix. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00069">69</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00071">defaultMatrixID</a>, <a class="el" href="a00369_source.html#l00383">isMarkovian()</a>, <a class="el" href="a00370_source.html#l00091">matrixList</a>, and <a class="el" href="a00370_source.html#l00065">numPos</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00070"></a>00070 {
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   <span class="comment">//check if the name is repetitive</span>
<a name="l00073"></a>00073   TransMatrixList::const_iterator matrixIt;
<a name="l00074"></a>00074   <span class="keywordflow">for</span> (matrixIt = <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.begin(); matrixIt != <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.end(); matrixIt++)
<a name="l00075"></a>00075   {
<a name="l00076"></a>00076     <span class="keywordflow">if</span> ((*matrixIt)-&gt;name == name )
<a name="l00077"></a>00077     {
<a name="l00078"></a>00078       std::string str = <span class="stringliteral">&quot;There are multiple matrices with the same name: &quot;</span> + name + <span class="stringliteral">&quot; in the configuration file!&quot;</span>;
<a name="l00079"></a>00079       opp_error (str.c_str());
<a name="l00080"></a>00080     }
<a name="l00081"></a>00081   }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="comment">// verify if the given matrix is Markovian</span>
<a name="l00085"></a>00085   <span class="keywordflow">if</span> ( !<a class="code" href="a00155.html#abe806a2afdeb239694094c24446f699f" title="Checks if a matrix can be a Markov transition matrix. All elements should be in the...">isMarkovian</a>(matrix) )
<a name="l00086"></a>00086   {
<a name="l00087"></a>00087     std::string str = <span class="stringliteral">&quot;Given transition matrix &quot;</span> + name + <span class="stringliteral">&quot; is not Markovian!&quot;</span>;
<a name="l00088"></a>00088     opp_error (str.c_str());
<a name="l00089"></a>00089   }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   <a class="code" href="a00155.html#a40b8581302bc59e9f3ee079b889d2eba" title="Data type for one instance of Markov transition matrix.">TransMatrix</a>* mat = <span class="keyword">new</span> <a class="code" href="a00155.html#a40b8581302bc59e9f3ee079b889d2eba" title="Data type for one instance of Markov transition matrix.">TransMatrix</a>;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   mat-&gt;name = name;
<a name="l00094"></a>00094   mat-&gt;matrix = <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00095"></a>00095   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
<a name="l00096"></a>00096   {
<a name="l00097"></a>00097     mat-&gt;matrix[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00098"></a>00098     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;numPos;++j)
<a name="l00099"></a>00099       mat-&gt;matrix[i][j] = matrix[i][j];
<a name="l00100"></a>00100   }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.push_back(mat);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="keywordflow">if</span> (thisDefault)
<a name="l00105"></a>00105     <a class="code" href="a00155.html#ae24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first...">defaultMatrixID</a> = <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.size()-1;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107   <span class="keywordflow">return</span> 0;
<a name="l00108"></a>00108 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a10abfb612543bbc52f6a13a0e138d822"></a><!-- doxytag: member="PostureTransition::addMatrix" ref="a10abfb612543bbc52f6a13a0e138d822" args="(double **, double **, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::addMatrix </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds two matrices with dimension numPos*numPose . </p>
<p>Function to add two matrix with the known dimensions as number of postures. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00445">445</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00065">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00369_source.html#l00488">extractMatrixFromSteadyState()</a>, and <a class="el" href="a00363_source.html#l00514">MoBANCoordinator::readConfigurationFile()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00446"></a>00446 {
<a name="l00447"></a>00447   <span class="keywordtype">int</span> i,j;
<a name="l00448"></a>00448   <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
<a name="l00449"></a>00449   {
<a name="l00450"></a>00450     <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00451"></a>00451       res[i][j] = mat1[i][j] + mat2[i][j];
<a name="l00452"></a>00452   }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac5c424a8372a3d6f39ccc06c88d4249f"></a><!-- doxytag: member="PostureTransition::addSteadyState" ref="ac5c424a8372a3d6f39ccc06c88d4249f" args="(std::string, double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addSteadyState </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>iVector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives a steady state vector, extracts the corresponding transition matrix considering the default matrix, and add to the list of given matrices. </p>
<p>This function creates a new instance of markov matrix to be filled with a derived matrix from the given steady state vector. The function first verifies if the given vector can be a steady state vector. Then extracts a markov matrix based on that and adds it to the list of given matrices. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00115">115</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00369_source.html#l00488">extractMatrixFromSteadyState()</a>, <a class="el" href="a00369_source.html#l00383">isMarkovian()</a>, <a class="el" href="a00370_source.html#l00091">matrixList</a>, and <a class="el" href="a00370_source.html#l00065">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00363_source.html#l00514">MoBANCoordinator::readConfigurationFile()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00116"></a>00116 {
<a name="l00117"></a>00117   <span class="comment">//check if the name is repetitive</span>
<a name="l00118"></a>00118   TransMatrixList::const_iterator matrixIt;
<a name="l00119"></a>00119   <span class="keywordflow">for</span> (matrixIt = <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.begin(); matrixIt != <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.end(); matrixIt++)
<a name="l00120"></a>00120   {
<a name="l00121"></a>00121     <span class="keywordflow">if</span> ((*matrixIt)-&gt;name == name )
<a name="l00122"></a>00122     {
<a name="l00123"></a>00123       std::string str = <span class="stringliteral">&quot;There are multiple matrices with the same name: &quot;</span> + name + <span class="stringliteral">&quot; in the configuration file!&quot;</span>;
<a name="l00124"></a>00124       opp_error (str.c_str());
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126   }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   <span class="comment">// check if the given matrix is Markovian</span>
<a name="l00129"></a>00129   <span class="keywordflow">if</span> ( !<a class="code" href="a00155.html#abe806a2afdeb239694094c24446f699f" title="Checks if a matrix can be a Markov transition matrix. All elements should be in the...">isMarkovian</a>(iVector) )
<a name="l00130"></a>00130   {
<a name="l00131"></a>00131     std::string str = <span class="stringliteral">&quot;Given steady state vector &quot;</span> + name + <span class="stringliteral">&quot; cannot be true!&quot;</span>;
<a name="l00132"></a>00132     opp_error (str.c_str());
<a name="l00133"></a>00133   }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135   <span class="comment">// make a local copy of the input steady state vector</span>
<a name="l00136"></a>00136   <span class="keywordtype">double</span> *steady = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00137"></a>00137   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; ++i)
<a name="l00138"></a>00138     steady[i] = iVector[i];
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   <a class="code" href="a00155.html#a40b8581302bc59e9f3ee079b889d2eba" title="Data type for one instance of Markov transition matrix.">TransMatrix</a>* mat = <span class="keyword">new</span> <a class="code" href="a00155.html#a40b8581302bc59e9f3ee079b889d2eba" title="Data type for one instance of Markov transition matrix.">TransMatrix</a>;
<a name="l00141"></a>00141   mat-&gt;name = name;
<a name="l00142"></a>00142   mat-&gt;matrix = <a class="code" href="a00155.html#a3ddddcbf58ad8e1edd23cf8023c7b974" title="Gets a steady state vector and return a matrix which is as close as posible to the...">extractMatrixFromSteadyState</a>(steady);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.push_back(mat);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   <span class="keywordflow">return</span> 0;
<a name="l00147"></a>00147 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a58c7924dfb8810ba37311217a7ba5c8d"></a><!-- doxytag: member="PostureTransition::addTimeDomain" ref="a58c7924dfb8810ba37311217a7ba5c8d" args="(std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addTimeDomain </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a time domain to the list with the given name and returns the index of the this time domain in the list. </p>
<p>Creates a new time domain instance and adds it to the list. The boundaries of the time domain is empty now. It will be filled later. The function returns the index of the time domain in the list as its output. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00191">191</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00135">timeDomainList</a>.</p>

<p>Referenced by <a class="el" href="a00363_source.html#l00514">MoBANCoordinator::readConfigurationFile()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00192"></a>00192 {
<a name="l00193"></a>00193   <span class="comment">//Check if the name is repetitive</span>
<a name="l00194"></a>00194   TimeDomainList::const_iterator timeIt;
<a name="l00195"></a>00195   <span class="keywordflow">for</span> (timeIt = <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.begin(); timeIt != <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.end(); timeIt++)
<a name="l00196"></a>00196   {
<a name="l00197"></a>00197     <span class="keywordflow">if</span> ((*timeIt)-&gt;name == name )
<a name="l00198"></a>00198     {
<a name="l00199"></a>00199       std::string str = <span class="stringliteral">&quot;There are multiple time domains with the same name: &quot;</span> + name + <span class="stringliteral">&quot; in the configuration file!&quot;</span>;
<a name="l00200"></a>00200       opp_error (str.c_str());
<a name="l00201"></a>00201     }
<a name="l00202"></a>00202   }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204   <a class="code" href="a00155.html#a9b888102d88c7dbb3a1359f6f8019784" title="Data type for one instance of time domain.">TimeDomainType</a>* time = <span class="keyword">new</span> <a class="code" href="a00155.html#a9b888102d88c7dbb3a1359f6f8019784" title="Data type for one instance of time domain.">TimeDomainType</a>;
<a name="l00205"></a>00205   time-&gt;name = name;
<a name="l00206"></a>00206   <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.push_back(time);
<a name="l00207"></a>00207   <span class="keywordflow">return</span> <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.size()-1;
<a name="l00208"></a>00208 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3ddddcbf58ad8e1edd23cf8023c7b974"></a><!-- doxytag: member="PostureTransition::extractMatrixFromSteadyState" ref="a3ddddcbf58ad8e1edd23cf8023c7b974" args="(double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** PostureTransition::extractMatrixFromSteadyState </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a steady state vector and return a matrix which is as close as posible to the default matrix and satisfies the given steady state. </p>
<p>This function receives a steady state vector and extracts a Markovian matrix which is as close as possible to the default markov matrix and satisfies the given steady state vector. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00488">488</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00369_source.html#l00445">addMatrix()</a>, <a class="el" href="a00370_source.html#l00071">defaultMatrixID</a>, <a class="el" href="a00370_source.html#l00091">matrixList</a>, <a class="el" href="a00369_source.html#l00426">multMatrix()</a>, <a class="el" href="a00369_source.html#l00473">multVector()</a>, <a class="el" href="a00370_source.html#l00065">numPos</a>, and <a class="el" href="a00369_source.html#l00459">subtractMatrix()</a>.</p>

<p>Referenced by <a class="el" href="a00369_source.html#l00115">addSteadyState()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00489"></a>00489 {
<a name="l00490"></a>00490   <span class="keywordtype">int</span> i,j;
<a name="l00491"></a>00491   <span class="keywordtype">double</span>** dafaultMat;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="comment">//make output matrix and an identity matrix and a temp</span>
<a name="l00494"></a>00494   <span class="keywordtype">double</span>** mat= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00495"></a>00495   <span class="keywordtype">double</span>** temp1= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00496"></a>00496   <span class="keywordtype">double</span>** temp2= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00497"></a>00497   <span class="keywordtype">double</span>** temp3= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00498"></a>00498   <span class="keywordtype">double</span>** identity = <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00499"></a>00499   <span class="keywordtype">int</span>** change = <span class="keyword">new</span> <span class="keywordtype">int</span>* [<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00500"></a>00500   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
<a name="l00501"></a>00501   {
<a name="l00502"></a>00502     mat[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00503"></a>00503     temp1[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00504"></a>00504     temp2[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00505"></a>00505     temp3[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00506"></a>00506     identity[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00507"></a>00507     change[i] = <span class="keyword">new</span> <span class="keywordtype">int</span> [numPos];
<a name="l00508"></a>00508 
<a name="l00509"></a>00509   }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511   <span class="keywordflow">for</span>(i=0; i &lt; numPos; i++)
<a name="l00512"></a>00512     <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00513"></a>00513       <span class="keywordflow">if</span> (i==j)
<a name="l00514"></a>00514         identity[i][j] = 1;
<a name="l00515"></a>00515       <span class="keywordflow">else</span>
<a name="l00516"></a>00516         identity[i][j] = 0;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 
<a name="l00519"></a>00519   <span class="keywordtype">double</span>* sum= <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00520"></a>00520   <span class="keywordtype">int</span>* changeSum= <span class="keyword">new</span> <span class="keywordtype">int</span> [numPos];
<a name="l00521"></a>00521 
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   dafaultMat = <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.at(<a class="code" href="a00155.html#ae24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first...">defaultMatrixID</a>)-&gt;matrix;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> numTry=0;numTry&lt;400;++numTry)
<a name="l00527"></a>00527   {
<a name="l00528"></a>00528     <a class="code" href="a00155.html#af48e8ee3a857b2425a9f1fe6ded08841" title="Subtracts two matrices with dimension numPos*numPose .">subtractMatrix</a>(identity,dafaultMat,temp1);
<a name="l00529"></a>00529     <a class="code" href="a00155.html#a2781afe68489f9278e755429787b22ec" title="Multiply a vector of size numPos with its transpose.">multVector</a>(vec,temp2);
<a name="l00530"></a>00530     <a class="code" href="a00155.html#abe7336508b8864deeb66872425662587" title="Multiplies two matrices with dimension numPos*numPose .">multMatrix</a>(temp1,temp2,temp3);
<a name="l00531"></a>00531     <a class="code" href="a00155.html#a10abfb612543bbc52f6a13a0e138d822" title="Adds two matrices with dimension numPos*numPose .">addMatrix</a>(dafaultMat,temp3,mat);
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     <span class="comment">//remember if it has not changed</span>
<a name="l00534"></a>00534     <span class="keywordflow">for</span>(i=0; i &lt; numPos; i++)
<a name="l00535"></a>00535       <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00536"></a>00536         change[i][j] = 1;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538     <span class="keywordflow">for</span>(j=0; j &lt; numPos; j++)
<a name="l00539"></a>00539       <span class="keywordflow">for</span>(i=0; i &lt; numPos ; i++)
<a name="l00540"></a>00540       {
<a name="l00541"></a>00541         <span class="keywordflow">if</span> ( mat[i][j] &lt; 0 ){
<a name="l00542"></a>00542           mat[i][j] = 0;
<a name="l00543"></a>00543           change[i][j]=0;
<a name="l00544"></a>00544         }
<a name="l00545"></a>00545         <span class="keywordflow">if</span> ( mat[i][j] &gt; 1 ){
<a name="l00546"></a>00546           mat[i][j] = 1;
<a name="l00547"></a>00547           change[i][j]=0;
<a name="l00548"></a>00548         }
<a name="l00549"></a>00549       }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 
<a name="l00552"></a>00552     <span class="keywordflow">for</span>(j=0; j &lt; numPos; j++)
<a name="l00553"></a>00553     {
<a name="l00554"></a>00554       sum[j] = 0;
<a name="l00555"></a>00555       changeSum[j]=0;
<a name="l00556"></a>00556       <span class="keywordflow">for</span>(i=0; i &lt; numPos ; i++)
<a name="l00557"></a>00557       {
<a name="l00558"></a>00558         sum[j] += mat[i][j];
<a name="l00559"></a>00559         changeSum[j] += change[i][j];
<a name="l00560"></a>00560       }
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     <span class="keywordflow">for</span>(j=0; j &lt; numPos; j++)
<a name="l00564"></a>00564       <span class="keywordflow">for</span>(i=0; i &lt; numPos ; i++)
<a name="l00565"></a>00565       {
<a name="l00566"></a>00566         <span class="keywordflow">if</span> (change[i][j] == 1)
<a name="l00567"></a>00567           mat[i][j] = mat[i][j]+ (1-sum[j])/changeSum[j];
<a name="l00568"></a>00568       }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570     dafaultMat = mat;
<a name="l00571"></a>00571   }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573   <span class="keywordflow">for</span>(j=0; j &lt; numPos; j++)
<a name="l00574"></a>00574     <span class="keywordflow">for</span>(i=0; i &lt; numPos ; i++)
<a name="l00575"></a>00575     {
<a name="l00576"></a>00576       <span class="keywordflow">if</span> ( mat[i][j] &lt; 0 )
<a name="l00577"></a>00577         mat[i][j] = 0;
<a name="l00578"></a>00578       <span class="keywordflow">if</span> ( mat[i][j] &gt; 1 )
<a name="l00579"></a>00579         mat[i][j] = 1;
<a name="l00580"></a>00580     }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 
<a name="l00583"></a>00583   EV &lt;&lt; <span class="stringliteral">&quot;Generated Markov matrix from the steady state: &quot;</span>&lt;&lt; endl;
<a name="l00584"></a>00584   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k &lt; numPos; ++k)
<a name="l00585"></a>00585   {
<a name="l00586"></a>00586     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f=0; f&lt;numPos ;++f)
<a name="l00587"></a>00587       EV &lt;&lt; mat[k][f]&lt;&lt;<span class="stringliteral">&quot;       &quot;</span>;
<a name="l00588"></a>00588     EV &lt;&lt; endl;
<a name="l00589"></a>00589   }
<a name="l00590"></a>00590 
<a name="l00591"></a>00591   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numPos;++i)
<a name="l00592"></a>00592   {
<a name="l00593"></a>00593     <span class="keyword">delete</span> temp1[i]; <span class="keyword">delete</span> temp2[i]; <span class="keyword">delete</span> temp3[i];
<a name="l00594"></a>00594     <span class="keyword">delete</span> identity[i];
<a name="l00595"></a>00595     <span class="keyword">delete</span> change[i];
<a name="l00596"></a>00596   }
<a name="l00597"></a>00597   <span class="keyword">delete</span> temp1; <span class="keyword">delete</span> temp2; <span class="keyword">delete</span> temp3;
<a name="l00598"></a>00598   <span class="keyword">delete</span> identity;
<a name="l00599"></a>00599   <span class="keyword">delete</span> change;
<a name="l00600"></a>00600   <span class="keyword">delete</span> sum;
<a name="l00601"></a>00601   <span class="keyword">delete</span> changeSum;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603 
<a name="l00604"></a>00604   <span class="keywordflow">return</span> mat;
<a name="l00605"></a>00605 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a299b33afdc27f467b3cdd472a397bb5a"></a><!-- doxytag: member="PostureTransition::findAreaType" ref="a299b33afdc27f467b3cdd472a397bb5a" args="(Coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::findAreaType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00062.html">Coord</a>&nbsp;</td>
          <td class="paramname"> <em>iLocation</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a location and finds the ID of the containing area type if there is. If not, return -1. </p>
<p>Looks for the first containing area type for the given location. It return the Id of the found area type. If no area type is found which contains the given location, it returns -1. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00359">359</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00113">areaTypeList</a>, and <a class="el" href="a00282_source.html#l00218">Coord::isInBoundary()</a>.</p>

<p>Referenced by <a class="el" href="a00369_source.html#l00306">getMatrix()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00360"></a>00360 {
<a name="l00361"></a>00361   <span class="keywordtype">int</span> locationID=0;
<a name="l00362"></a>00362   AreaTypeList::const_iterator areaIt;
<a name="l00363"></a>00363   <span class="keywordflow">for</span> (areaIt = <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.begin(); areaIt != <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.end(); areaIt++)
<a name="l00364"></a>00364   {
<a name="l00365"></a>00365     std::vector&lt;AreaBound*&gt; boundList = (*areaIt)-&gt;boundries;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367     std::vector&lt;AreaBound*&gt;::const_iterator bound;
<a name="l00368"></a>00368     <span class="keywordflow">for</span> (bound = boundList.begin(); bound != boundList.end(); bound++)
<a name="l00369"></a>00369     {
<a name="l00370"></a>00370       <span class="keywordflow">if</span> ( iLocation.<a class="code" href="a00062.html#a7a42e29d7a15ed0b53e47137549e00a6" title="Checks if this coordinate is inside a specified rectangle.">isInBoundary</a>( (*bound)-&gt;low ,(*bound)-&gt;high ) )
<a name="l00371"></a>00371         <span class="keywordflow">return</span> locationID;
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373     ++locationID;
<a name="l00374"></a>00374   }
<a name="l00375"></a>00375   EV &lt;&lt; <span class="stringliteral">&quot;Area Type not found&quot;</span> &lt;&lt; endl;
<a name="l00376"></a>00376   <span class="keywordflow">return</span> -1;
<a name="l00377"></a>00377 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad2663f9084d4a805296bc0939f28001c"></a><!-- doxytag: member="PostureTransition::findTimeDomain" ref="ad2663f9084d4a805296bc0939f28001c" args="(simtime_t_cref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::findTimeDomain </td>
          <td>(</td>
          <td class="paramtype">simtime_t_cref&nbsp;</td>
          <td class="paramname"> <em>iTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a time and finds the ID of the containing time domain if there is. If not, return -1. </p>
<p>Looks for the first containing time domain for the given time instance. It return the Id of the found time domain. If no time domain is found which contains the given time instance, it returns -1. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00335">335</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00135">timeDomainList</a>.</p>

<p>Referenced by <a class="el" href="a00369_source.html#l00306">getMatrix()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00336"></a>00336 {
<a name="l00337"></a>00337   <span class="keywordtype">int</span> timeID=0;
<a name="l00338"></a>00338   TimeDomainList::const_iterator timeIt;
<a name="l00339"></a>00339   <span class="keywordflow">for</span> (timeIt = <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.begin(); timeIt != <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.end(); timeIt++)
<a name="l00340"></a>00340   {
<a name="l00341"></a>00341     std::vector&lt;TimeBound*&gt; boundList = (*timeIt)-&gt;boundries;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     std::vector&lt;TimeBound*&gt;::const_iterator bound;
<a name="l00344"></a>00344     <span class="keywordflow">for</span> (bound = boundList.begin(); bound != boundList.end(); bound++)
<a name="l00345"></a>00345     {
<a name="l00346"></a>00346       <span class="keywordflow">if</span> ( iTime &gt;= (*bound)-&gt;low &amp;&amp; iTime &lt; (*bound)-&gt;high)
<a name="l00347"></a>00347         <span class="keywordflow">return</span> timeID;
<a name="l00348"></a>00348     }
<a name="l00349"></a>00349     ++timeID;
<a name="l00350"></a>00350   }
<a name="l00351"></a>00351   EV &lt;&lt; <span class="stringliteral">&quot;Time domain not found&quot;</span> &lt;&lt; endl;
<a name="l00352"></a>00352   <span class="keywordflow">return</span> -1;
<a name="l00353"></a>00353 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a93efe929bf92a744b9343730011579bf"></a><!-- doxytag: member="PostureTransition::getMatrix" ref="a93efe929bf92a744b9343730011579bf" args="(simtime_t_cref, Coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** PostureTransition::getMatrix </td>
          <td>(</td>
          <td class="paramtype">simtime_t_cref&nbsp;</td>
          <td class="paramname"> <em>iTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00062.html">Coord</a>&nbsp;</td>
          <td class="paramname"> <em>iLocation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a time and location, and returns the corresponding Markov transition matrix. </p>
<p>This function is actually the main usage of this class. It gets a time instance and a location within the simulation area, and then looks for the first fitting combination. If found, it returns the specified Markov transition matrix for that combination as its output. If no combination is found, it returns the default matrix. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00306">306</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00148">combinationList</a>, <a class="el" href="a00370_source.html#l00071">defaultMatrixID</a>, <a class="el" href="a00369_source.html#l00359">findAreaType()</a>, <a class="el" href="a00369_source.html#l00335">findTimeDomain()</a>, <a class="el" href="a00282_source.html#l00069">Coord::info()</a>, and <a class="el" href="a00370_source.html#l00091">matrixList</a>.</p>

<p>Referenced by <a class="el" href="a00363_source.html#l00244">MoBANCoordinator::selectPosture()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00307"></a>00307 {
<a name="l00308"></a>00308   <span class="keywordtype">int</span> timeID,locationID,matrixID;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310   timeID = <a class="code" href="a00155.html#ad2663f9084d4a805296bc0939f28001c" title="Gets a time and finds the ID of the containing time domain if there is. If not, return...">findTimeDomain</a>(iTime);
<a name="l00311"></a>00311   locationID = <a class="code" href="a00155.html#a299b33afdc27f467b3cdd472a397bb5a" title="Gets a location and finds the ID of the containing area type if there is. If not...">findAreaType</a>(iLocation);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   matrixID = <a class="code" href="a00155.html#ae24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first...">defaultMatrixID</a>;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   CombinationList::const_iterator combIt;
<a name="l00317"></a>00317   <span class="keywordflow">for</span> (combIt = <a class="code" href="a00155.html#ab4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>.begin(); combIt != <a class="code" href="a00155.html#ab4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>.end(); combIt++)
<a name="l00318"></a>00318   {
<a name="l00319"></a>00319     <span class="keywordflow">if</span> ( (*combIt)-&gt;timeID == timeID &amp;&amp; (*combIt)-&gt;areaID == locationID)
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       matrixID = (*combIt)-&gt;matrixID;
<a name="l00322"></a>00322       <span class="keywordflow">break</span>;
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324   }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   EV &lt;&lt; <span class="stringliteral">&quot;The corresponding Markov matrix for time&quot;</span> &lt;&lt; iTime &lt;&lt;<span class="stringliteral">&quot; and location &quot;</span> &lt;&lt; iLocation.<a class="code" href="a00062.html#a86994bfa7096155d951abb03dcf30bf1" title="Returns a string with the value of the coordinate.">info</a>() &lt;&lt; <span class="stringliteral">&quot; is: &quot;</span> &lt;&lt; <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.at(matrixID)-&gt;name &lt;&lt; endl;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <span class="keywordflow">return</span> <a class="code" href="a00155.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.at(matrixID)-&gt;matrix;
<a name="l00329"></a>00329 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a67a8cc00702db7106fc5b38447398856"></a><!-- doxytag: member="PostureTransition::isMarkovian" ref="a67a8cc00702db7106fc5b38447398856" args="(double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::isMarkovian </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a vector can be the steady state of a Markov chain. All elements should be in the range [0,1] and the sum of elements should be 1. </p>
<p>Verifies if a vector can be the steady state of a Markov model. Each element of the matrix should be in the range [0 1]. Further, the sum of all elements should be one. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00407">407</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00284_source.html#l00113">FWMath::close()</a>, and <a class="el" href="a00370_source.html#l00065">numPos</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00408"></a>00408 {
<a name="l00409"></a>00409   <span class="keywordtype">double</span> sumCol=0;
<a name="l00410"></a>00410   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
<a name="l00411"></a>00411   {
<a name="l00412"></a>00412     <span class="keywordflow">if</span> (vec[i] &lt; 0 || vec[i]&gt; 1)
<a name="l00413"></a>00413       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00414"></a>00414     sumCol += vec[i];
<a name="l00415"></a>00415   }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="keywordflow">if</span> ( !<a class="code" href="a00092.html#a38d2500887b49de2a2b5f8610f7ba6d1">FWMath::close</a>(sumCol , 1.0 ) )
<a name="l00418"></a>00418     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00419"></a>00419   <span class="keywordflow">else</span>
<a name="l00420"></a>00420     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00421"></a>00421 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abe806a2afdeb239694094c24446f699f"></a><!-- doxytag: member="PostureTransition::isMarkovian" ref="abe806a2afdeb239694094c24446f699f" args="(double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::isMarkovian </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>matrix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a matrix can be a Markov transition matrix. All elements should be in the range [0,1] and elements of each column of the matrix should add up to 1. </p>
<p>Verifies if a matrix can be a Markovian transition matrix. Each element of the matrix should be in the range [0 1]. Further, all elements of each column should adds up to one. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00383">383</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00284_source.html#l00113">FWMath::close()</a>, and <a class="el" href="a00370_source.html#l00065">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00369_source.html#l00069">addMatrix()</a>, and <a class="el" href="a00369_source.html#l00115">addSteadyState()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00384"></a>00384 {
<a name="l00385"></a>00385   <span class="keywordtype">double</span> sumCol;
<a name="l00386"></a>00386   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;<a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++j)
<a name="l00387"></a>00387   {
<a name="l00388"></a>00388     sumCol = 0;
<a name="l00389"></a>00389     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numPos;++i)
<a name="l00390"></a>00390     {
<a name="l00391"></a>00391       <span class="keywordflow">if</span> (matrix[i][j] &lt; 0 || matrix[i][j] &gt; 1)
<a name="l00392"></a>00392         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00393"></a>00393       sumCol += matrix[i][j];
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396     <span class="keywordflow">if</span> (!<a class="code" href="a00092.html#a38d2500887b49de2a2b5f8610f7ba6d1">FWMath::close</a>(sumCol , 1.0 ))
<a name="l00397"></a>00397       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00398"></a>00398   }
<a name="l00399"></a>00399 
<a name="l00400"></a>00400   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00401"></a>00401 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abe7336508b8864deeb66872425662587"></a><!-- doxytag: member="PostureTransition::multMatrix" ref="abe7336508b8864deeb66872425662587" args="(double **, double **, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::multMatrix </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies two matrices with dimension numPos*numPose . </p>
<p>Function to multiply two matrix with the known dimensions as number of postures. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00426">426</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00065">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00369_source.html#l00488">extractMatrixFromSteadyState()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00427"></a>00427 {
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="keywordtype">int</span> i,j,l;
<a name="l00430"></a>00430   <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
<a name="l00431"></a>00431   {
<a name="l00432"></a>00432     <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00433"></a>00433     {
<a name="l00434"></a>00434       res[i][j]=0;
<a name="l00435"></a>00435       <span class="keywordflow">for</span>(l=0; l &lt; numPos ; l++)
<a name="l00436"></a>00436         res[i][j] += mat1[i][l] * mat2[l][j];
<a name="l00437"></a>00437     }
<a name="l00438"></a>00438   }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2781afe68489f9278e755429787b22ec"></a><!-- doxytag: member="PostureTransition::multVector" ref="a2781afe68489f9278e755429787b22ec" args="(double *, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::multVector </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a vector of size numPos with its transpose. </p>
<p>Function to multiply a vector by its transpose (pi . pi^T). The size in equal to the number of postures. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00473">473</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00065">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00369_source.html#l00488">extractMatrixFromSteadyState()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00474"></a>00474 {
<a name="l00475"></a>00475   <span class="keywordtype">int</span> i,j;
<a name="l00476"></a>00476   <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
<a name="l00477"></a>00477   {
<a name="l00478"></a>00478     <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00479"></a>00479       res[i][j] = vec[i] * vec[j];
<a name="l00480"></a>00480   }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a309ed6acf7eca6469f0ea0f06ee41780"></a><!-- doxytag: member="PostureTransition::setAreaBoundry" ref="a309ed6acf7eca6469f0ea0f06ee41780" args="(int, Coord, Coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::setAreaBoundry </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00062.html">Coord</a>&nbsp;</td>
          <td class="paramname"> <em>lowBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00062.html">Coord</a>&nbsp;</td>
          <td class="paramname"> <em>highBound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the given boundary to the existing area type specified by the given ID . </p>
<p>This function gets an index of an existing area type and adds the given boundary to the boundary list of that area type. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00176">176</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00113">areaTypeList</a>.</p>

<p>Referenced by <a class="el" href="a00363_source.html#l00514">MoBANCoordinator::readConfigurationFile()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00177"></a>00177 {
<a name="l00178"></a>00178   <a class="code" href="a00155.html#aefc213d43332c35fdb8ef1c665ef7ba3" title="Data type for one instance of the area (space) boundary.">AreaBound</a>* bound=<span class="keyword">new</span> <a class="code" href="a00155.html#aefc213d43332c35fdb8ef1c665ef7ba3" title="Data type for one instance of the area (space) boundary.">AreaBound</a>;
<a name="l00179"></a>00179   bound-&gt;low = lowBound;
<a name="l00180"></a>00180   bound-&gt;high = highBound;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <a class="code" href="a00155.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.at(<span class="keywordtype">id</span>)-&gt;boundries.push_back(bound);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00185"></a>00185 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac26d34882db804ce0aa2a8081e526729"></a><!-- doxytag: member="PostureTransition::setTimeBoundry" ref="ac26d34882db804ce0aa2a8081e526729" args="(int, simtime_t_cref, simtime_t_cref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::setTimeBoundry </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t_cref&nbsp;</td>
          <td class="paramname"> <em>lowBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t_cref&nbsp;</td>
          <td class="paramname"> <em>highBound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the given boundary to the existing time domain specified by the given ID . </p>
<p>This function gets an index of an existing time domain and adds the given boundary to the boundary list of that time domain. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00213">213</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00135">timeDomainList</a>.</p>

<p>Referenced by <a class="el" href="a00363_source.html#l00514">MoBANCoordinator::readConfigurationFile()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00214"></a>00214 {
<a name="l00215"></a>00215   <a class="code" href="a00155.html#af0f85ea329cfde097850b5582d3735d1" title="Data type for one instance of the time boundary.">TimeBound</a>* bound=<span class="keyword">new</span> <a class="code" href="a00155.html#af0f85ea329cfde097850b5582d3735d1" title="Data type for one instance of the time boundary.">TimeBound</a>;
<a name="l00216"></a>00216   bound-&gt;low = lowBound;
<a name="l00217"></a>00217   bound-&gt;high = highBound;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <a class="code" href="a00155.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.at(<span class="keywordtype">id</span>)-&gt;boundries.push_back(bound);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00222"></a>00222 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af48e8ee3a857b2425a9f1fe6ded08841"></a><!-- doxytag: member="PostureTransition::subtractMatrix" ref="af48e8ee3a857b2425a9f1fe6ded08841" args="(double **, double **, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::subtractMatrix </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtracts two matrices with dimension numPos*numPose . </p>
<p>Function to subtract two matrix with the known dimensions as number of postures. </p>

<p>Definition at line <a class="el" href="a00369_source.html#l00459">459</a> of file <a class="el" href="a00369_source.html">PostureTransition.cc</a>.</p>

<p>References <a class="el" href="a00370_source.html#l00065">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00369_source.html#l00488">extractMatrixFromSteadyState()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00460"></a>00460 {
<a name="l00461"></a>00461   <span class="keywordtype">int</span> i,j;
<a name="l00462"></a>00462   <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00155.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
<a name="l00463"></a>00463   {
<a name="l00464"></a>00464     <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00465"></a>00465       res[i][j] = mat1[i][j] - mat2[i][j];
<a name="l00466"></a>00466   }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/mobility/<a class="el" href="a00370_source.html">PostureTransition.h</a></li>
<li>src/modules/mobility/<a class="el" href="a00369_source.html">PostureTransition.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Dec 14 16:01:50 2011 for MiXiM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
