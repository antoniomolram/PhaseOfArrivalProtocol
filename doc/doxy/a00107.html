<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00455.html">mappingDetails - mostly internal mapping classes</a>]</small>
</h1><!-- doxytag: class="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;" --><!-- doxytag: inherits="InterpolatorBase&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;" -->
<p>Specialization of the Linear-template which provides LinearInterpolation for pointer two Mappings. Used by <a class="el" href="a00128.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional...">MultiDimMapping</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00275_source.html">MappingUtils.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="a00101.html">InterpolatorBase&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;</a>.</p>
<div class="dynheader">
Collaboration diagram for Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;:</div>
<div class="dynsection">
<div class="center"><img src="a00649.png" border="0" usemap="#Linear_3_01std_1_1map_3_01Argument_1_1mapped__type_00_01Mapping_01_5_01_4_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="Linear_3_01std_1_1map_3_01Argument_1_1mapped__type_00_01Mapping_01_5_01_4_01_4_coll__map" id="Linear_3_01std_1_1map_3_01Argument_1_1mapped__type_00_01Mapping_01_5_01_4_01_4_coll__map">
<area shape="rect" href="a00101.html" title="InterpolatorBase\&lt; std::map\&lt; Argument::mapped_type, Mapping * \&gt; \&gt;" alt="" coords="5,5,427,32"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a00650.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4040145fe6161ede2994bd6762a1d533"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::storage_type" ref="a4040145fe6161ede2994bd6762a1d533" args="" -->
typedef <br class="typebreak"/>
base_class_type::storage_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>storage_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7116a5748d75ea3105be24501b9ec84"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::container_type" ref="ac7116a5748d75ea3105be24501b9ec84" args="" -->
typedef <br class="typebreak"/>
base_class_type::container_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>container_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa50b0bf0efe24b268bd2d1338f3d1ac6"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::key_type" ref="aa50b0bf0efe24b268bd2d1338f3d1ac6" args="" -->
typedef base_class_type::key_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab59de965f056c3e07cf77dceadd2ea55"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::key_cref_type" ref="ab59de965f056c3e07cf77dceadd2ea55" args="" -->
typedef <br class="typebreak"/>
base_class_type::key_cref_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>key_cref_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35b6316a117349e57e2b9d66851d2f85"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::mapped_type" ref="a35b6316a117349e57e2b9d66851d2f85" args="" -->
typedef <br class="typebreak"/>
base_class_type::mapped_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95f8cc4fc9eac2410529e020c445c495"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::mapped_cref_type" ref="a95f8cc4fc9eac2410529e020c445c495" args="" -->
typedef <br class="typebreak"/>
base_class_type::mapped_cref_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapped_cref_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad633b9d04356417275b775ea432dbc21"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::pair_type" ref="ad633b9d04356417275b775ea432dbc21" args="" -->
typedef base_class_type::pair_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>pair_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c815e58c3878a834078d9dd9a13b4f8"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::iterator" ref="a3c815e58c3878a834078d9dd9a13b4f8" args="" -->
typedef base_class_type::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d23ddc7054d05e1318a3f29f1c7ed02"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::const_iterator" ref="a1d23ddc7054d05e1318a3f29f1c7ed02" args="" -->
typedef <br class="typebreak"/>
base_class_type::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff04706e49346c00d4fe1148eda956d3"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::comparator_type" ref="aff04706e49346c00d4fe1148eda956d3" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="a00145.html">base_class_type::comparator_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>comparator_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12116f0bfeffd29c01086e2fdf9ef36f"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::interpolated" ref="a12116f0bfeffd29c01086e2fdf9ef36f" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="a00099.html">base_class_type::interpolated</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>interpolated</b></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a003c98781f6a5cb06766457bd2b2900e"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::Linear" ref="a003c98781f6a5cb06766457bd2b2900e" args="(mapped_cref_type oorv)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>Linear</b> (mapped_cref_type oorv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfa0dc198816e5fc447edcca0b871bcb"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::Linear" ref="acfa0dc198816e5fc447edcca0b871bcb" args="(const _Self &amp;o)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>Linear</b> (const <a class="el" href="a00107.html">_Self</a> &amp;o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00099.html">interpolated</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html#ae9b11d23c7aa15f1f4f182caa81ce74b">operator()</a> (const const_iterator &amp;first, const const_iterator &amp;last, key_cref_type pos, const_iterator upperBound) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor operator of this class which linear interpolates the value at the passed position using the values between the passed Iterators.  <a href="#ae9b11d23c7aa15f1f4f182caa81ce74b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31035d6e59ff98439fc3470be035f74c"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::base_class_type" ref="a31035d6e59ff98439fc3470be035f74c" args="" -->
typedef <a class="el" href="a00101.html">InterpolatorBase</a><br class="typebreak"/>
&lt; std::map<br class="typebreak"/>
&lt; Argument::mapped_type, <br class="typebreak"/>
<a class="el" href="a00121.html">Mapping</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>base_class_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac907b0558ebfa37d69b495b499839996"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::_Self" ref="ac907b0558ebfa37d69b495b499839996" args="" -->
typedef <a class="el" href="a00106.html">Linear</a>&lt; std::map<br class="typebreak"/>
&lt; Argument::mapped_type, <br class="typebreak"/>
<a class="el" href="a00121.html">Mapping</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>_Self</b></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab6548d5edb2e331e905f569d0e6cf0a"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::linearInterpolationFactor" ref="aab6548d5edb2e331e905f569d0e6cf0a" args="(key_cref_type t, key_cref_type t0, key_cref_type t1)" -->
static <br class="typebreak"/>
ConstMapping::argument_value_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html#aab6548d5edb2e331e905f569d0e6cf0a">linearInterpolationFactor</a> (key_cref_type t, key_cref_type t0, key_cref_type t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">calculates the linear interpolation factor used for the created LinearIntplMappings. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;&gt;<br/>
 class Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;</h3>

<p>Specialization of the Linear-template which provides LinearInterpolation for pointer two Mappings. Used by <a class="el" href="a00128.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional...">MultiDimMapping</a>. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Karl Wessel </dd></dl>

<p>Definition at line <a class="el" href="a00275_source.html#l00743">743</a> of file <a class="el" href="a00275_source.html">MappingUtils.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae9b11d23c7aa15f1f4f182caa81ce74b"></a><!-- doxytag: member="Linear&lt; std::map&lt; Argument::mapped_type, Mapping * &gt; &gt;::operator()" ref="ae9b11d23c7aa15f1f4f182caa81ce74b" args="(const const_iterator &amp;first, const const_iterator &amp;last, key_cref_type pos, const_iterator upperBound) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00099.html">interpolated</a> <a class="el" href="a00106.html">Linear</a>&lt; std::map&lt; Argument::mapped_type, <a class="el" href="a00121.html">Mapping</a> * &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_cref_type&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&nbsp;</td>
          <td class="paramname"> <em>upperBound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Functor operator of this class which linear interpolates the value at the passed position using the values between the passed Iterators. </p>
<p>The upperBound-iterator has to point two the entry next bigger as the passed position to interpolate.</p>
<p>The returned instance of interpolated represents the result. Which can be either an actual entry of the interpolated map (if the position two interpolate was exactly that. Or it can be an interpolated value, if the passed position was between two entries of the map. This state can be retrieved with the "isInterpolated"-Member of the returned "interpolated". </p>

<p>Definition at line <a class="el" href="a00275_source.html#l00788">788</a> of file <a class="el" href="a00275_source.html">MappingUtils.h</a>.</p>

<p>References <a class="el" href="a00268_source.html#l00453">Linear&lt; _ContainerType &gt;::linearInterpolationFactor()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00791"></a>00791                                                                   {
<a name="l00792"></a>00792     <span class="keywordflow">if</span>(first == last) {
<a name="l00793"></a>00793       <span class="keywordflow">return</span> base_class_type::outOfRangeVal;
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795     <span class="keywordflow">if</span>(upperBound == first){
<a name="l00796"></a>00796       <span class="keywordflow">return</span> asInterpolated(upperBound-&gt;second, <span class="keyword">true</span>);
<a name="l00797"></a>00797     }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799     const_iterator right = upperBound;
<a name="l00800"></a>00800     const_iterator left  = --upperBound;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802     <span class="keywordflow">if</span>(left-&gt;first == pos)
<a name="l00803"></a>00803       <span class="keywordflow">return</span> asInterpolated(left-&gt;second, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l00804"></a>00804 
<a name="l00805"></a>00805     <span class="keywordflow">if</span>(right == last){
<a name="l00806"></a>00806       <span class="keywordflow">return</span> asInterpolated(left-&gt;second, <span class="keyword">true</span>);
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809     <span class="keywordflow">return</span> interpolated(<a class="code" href="a00108.html" title="Helper class which represents a linear interpolation between two other mappings.">LinearIntplMapping</a>(left-&gt;second, right-&gt;second, <a class="code" href="a00107.html#aab6548d5edb2e331e905f569d0e6cf0a" title="calculates the linear interpolation factor used for the created LinearIntplMappings...">linearInterpolationFactor</a>(pos, left-&gt;first, right-&gt;first)));
<a name="l00810"></a>00810   }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/base/phyLayer/<a class="el" href="a00275_source.html">MappingUtils.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Dec 14 16:01:49 2011 for MiXiM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
