<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: MappingUtils Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MappingUtils Class Reference<br/>
<small>
[<a class="el" href="a00454.html">mapping - classes representing mathematical mappings</a>]</small>
</h1><!-- doxytag: class="MappingUtils" -->
<p>Provides several utility methods for Mappings.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00275_source.html">MappingUtils.h</a>&gt;</code></p>

<p><a href="a00678.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad235ea24201e93c2b28a1c65c2f4fa6e"></a><!-- doxytag: member="MappingUtils::MappingBuffer" ref="ad235ea24201e93c2b28a1c65c2f4fa6e" args="" -->
typedef std::list&lt; const <br class="typebreak"/>
<a class="el" href="a00055.html">ConstMapping</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>MappingBuffer</b></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a0c61c76ba04339162563339b23bf42e9">createMapping</a> (const <a class="el" href="a00083.html">DimensionSet</a> &amp;domain=<a class="el" href="a00083.html">DimensionSet</a>(<a class="el" href="a00082.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>), <a class="el" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643">Mapping::InterpolationMethod</a> intpl=Mapping::LINEAR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an appropriate changeable <a class="el" href="a00121.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type...">Mapping</a> with the specified domain and the specified interpolation method.  <a href="#a0c61c76ba04339162563339b23bf42e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#acca15c41da58e61619e67d1ec1538a9e">createMapping</a> (Mapping::argument_value_cref_t outOfRangeValue, const <a class="el" href="a00083.html">DimensionSet</a> &amp;domain=<a class="el" href="a00083.html">DimensionSet</a>(<a class="el" href="a00082.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>), <a class="el" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643">Mapping::InterpolationMethod</a> intpl=Mapping::LINEAR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an appropriate changeable <a class="el" href="a00121.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type...">Mapping</a> with the specified domain and the specified interpolation method.  <a href="#acca15c41da58e61619e67d1ec1538a9e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a697a3bc265fe0664080c65c66e3f57cf"></a><!-- doxytag: member="MappingUtils::applyElementWiseOperator" ref="a697a3bc265fe0664080c65c66e3f57cf" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, const Argument &amp;intvlStart, const Argument &amp;intvlEnd, Operator op)" -->
template&lt;class Operator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>applyElementWiseOperator</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2, const <a class="el" href="a00009.html">Argument</a> &amp;intvlStart, const <a class="el" href="a00009.html">Argument</a> &amp;intvlEnd, Operator op)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fab9aa16e1d7e6fc03793eb91a90c8d"></a><!-- doxytag: member="MappingUtils::applyElementWiseOperator" ref="a6fab9aa16e1d7e6fc03793eb91a90c8d" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Operator op, Mapping::argument_value_cref_t outOfRangeVal=Argument::MappedZero, bool contOutOfRange=true)" -->
template&lt;class Operator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>applyElementWiseOperator</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2, Operator op, Mapping::argument_value_cref_t outOfRangeVal=<a class="el" href="a00009.html#a8523627cdc70492e5e0935b9a3a78cc4">Argument::MappedZero</a>, bool contOutOfRange=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a11550dc6dc55beb5a14def9ffb501a40">multiply</a> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies the passed functions element-wise with each other and returns the result in a new Function.  <a href="#a11550dc6dc55beb5a14def9ffb501a40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d8bf65254d099c87948c1c300986696"></a><!-- doxytag: member="MappingUtils::add" ref="a0d8bf65254d099c87948c1c300986696" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2)" -->
static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>add</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37d38fd0a9593e6f055ac8d90758965e"></a><!-- doxytag: member="MappingUtils::subtract" ref="a37d38fd0a9593e6f055ac8d90758965e" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2)" -->
static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>subtract</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ccda215590380a9798e4dd51ede69c"></a><!-- doxytag: member="MappingUtils::divide" ref="ad5ccda215590380a9798e4dd51ede69c" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2)" -->
static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>divide</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab8b49872f55a0162ee1c25f0f4af5b1"></a><!-- doxytag: member="MappingUtils::multiply" ref="aab8b49872f55a0162ee1c25f0f4af5b1" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)" -->
static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>multiply</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a372c8f56f2e7f5dc0ce06daf4e0db128"></a><!-- doxytag: member="MappingUtils::add" ref="a372c8f56f2e7f5dc0ce06daf4e0db128" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)" -->
static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>add</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a217539e608efcc8ccf7766c9b9733a17"></a><!-- doxytag: member="MappingUtils::subtract" ref="a217539e608efcc8ccf7766c9b9733a17" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)" -->
static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>subtract</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf2fb8da23ea9c12f9946559fe954c8"></a><!-- doxytag: member="MappingUtils::divide" ref="a2cf2fb8da23ea9c12f9946559fe954c8" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)" -->
static <a class="el" href="a00121.html">Mapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>divide</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00055.html">ConstMapping</a> &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Argument::mapped_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#afbe1a1e1d2becd66d2c0d5a8ac42b478">findMax</a> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;m, Argument::mapped_type_cref cRetNotFound=<a class="el" href="a00123.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates over the passed mapping and returns value at the key entry with the highest value.  <a href="#afbe1a1e1d2becd66d2c0d5a8ac42b478"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Argument::mapped_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ac9d1a808dbca5da873af58f1da4cbcf4">findMax</a> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;m, const <a class="el" href="a00009.html">Argument</a> &amp;min, const <a class="el" href="a00009.html">Argument</a> &amp;max, Argument::mapped_type_cref cRetNotFound=<a class="el" href="a00123.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates over the passed mapping and returns the value at the key entry with the highest value in the range defined by the passed min and max parameter.  <a href="#ac9d1a808dbca5da873af58f1da4cbcf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Argument::mapped_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a5d9c4e3dcaddccfa65f21212d0fee2cf">findMin</a> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;m, Argument::mapped_type_cref cRetNotFound=<a class="el" href="a00123.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates over the passed mapping and returns value at the key entry with the smallest value.  <a href="#a5d9c4e3dcaddccfa65f21212d0fee2cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Argument::mapped_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#adb9e9ced268b9a5d1d4f6d34738654aa">findMin</a> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;m, const <a class="el" href="a00009.html">Argument</a> &amp;min, const <a class="el" href="a00009.html">Argument</a> &amp;max, Argument::mapped_type_cref cRetNotFound=<a class="el" href="a00123.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates over the passed mapping and returns the value at the key entry with the smallest value in the range defined by the passed min and max parameter.  <a href="#adb9e9ced268b9a5d1d4f6d34738654aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#aa6e9896c0c961ade987bc00ec5f4e6a0">addDiscontinuity</a> (<a class="el" href="a00121.html">Mapping</a> *m, const <a class="el" href="a00009.html">Argument</a> &amp;pos, Argument::mapped_type_cref value, simtime_t_cref limitTime, Argument::mapped_type_cref limitValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a discontinuity in time-dimension, i.e. its representation, to a passed mapping.  <a href="#aa6e9896c0c961ade987bc00ec5f4e6a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf7c04c0adea7f6e9fe49101b0197c3"></a><!-- doxytag: member="MappingUtils::pre" ref="a2cf7c04c0adea7f6e9fe49101b0197c3" args="(simtime_t_cref t)" -->
static simtime_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a2cf7c04c0adea7f6e9fe49101b0197c3">pre</a> (simtime_t_cref t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the closest value of simtime before passed value <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31183e79401391df3e2d250846ae8d0e"></a><!-- doxytag: member="MappingUtils::post" ref="a31183e79401391df3e2d250846ae8d0e" args="(simtime_t_cref t)" -->
static simtime_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a31183e79401391df3e2d250846ae8d0e">post</a> (simtime_t_cref t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the closest value of simtime after passed values <br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const Argument::mapped_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a> = std::numeric_limits&lt;Argument::mapped_type&gt;::infinity()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default value for <a class="el" href="a00123.html#a5d9c4e3dcaddccfa65f21212d0fee2cf" title="Iterates over the passed mapping and returns value at the key entry with the smallest...">findMin()</a> functions if it does not find a minimum element.  <a href="#a3db893e8948a5af5fe947fb0740d86ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const Argument::mapped_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a> = -std::numeric_limits&lt;Argument::mapped_type&gt;::infinity()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default value for <a class="el" href="a00123.html#afbe1a1e1d2becd66d2c0d5a8ac42b478" title="Iterates over the passed mapping and returns value at the key entry with the highest...">findMax()</a> functions if it does not find a maximum element.  <a href="#a2a3f154e68d94b4b5a5ed580bb3e756f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54b5597499f282d0f2c9dd18894698f9"></a><!-- doxytag: member="MappingUtils::createCompatibleMapping" ref="a54b5597499f282d0f2c9dd18894698f9" args="(const ConstMapping &amp;src, const ConstMapping &amp;dst)" -->
static const <a class="el" href="a00055.html">ConstMapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>createCompatibleMapping</b> (const <a class="el" href="a00055.html">ConstMapping</a> &amp;src, const <a class="el" href="a00055.html">ConstMapping</a> &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a768601098bcb0d998be2c742126433"></a><!-- doxytag: member="MappingUtils::iterateToNext" ref="a6a768601098bcb0d998be2c742126433" args="(ConstMappingIterator *it1, ConstMappingIterator *it2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterateToNext</b> (<a class="el" href="a00056.html">ConstMappingIterator</a> *it1, <a class="el" href="a00056.html">ConstMappingIterator</a> *it2)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Provides several utility methods for Mappings. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Karl Wessel </dd></dl>

<p>Definition at line <a class="el" href="a00275_source.html#l01797">1797</a> of file <a class="el" href="a00275_source.html">MappingUtils.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa6e9896c0c961ade987bc00ec5f4e6a0"></a><!-- doxytag: member="MappingUtils::addDiscontinuity" ref="aa6e9896c0c961ade987bc00ec5f4e6a0" args="(Mapping *m, const Argument &amp;pos, Argument::mapped_type_cref value, simtime_t_cref limitTime, Argument::mapped_type_cref limitValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void MappingUtils::addDiscontinuity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00121.html">Mapping</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00009.html">Argument</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t_cref&nbsp;</td>
          <td class="paramname"> <em>limitTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&nbsp;</td>
          <td class="paramname"> <em>limitValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a discontinuity in time-dimension, i.e. its representation, to a passed mapping. </p>
<p>This is done by setting a regular entry and a limit-entry. The limit-entry shall be very close to the regular entry (on its left or right).</p>
<p>The implementation works simply by adding the limit-value as a separate entry at the position of the limit-time. This means that this methods adds a total of two entries to the passed mapping.</p>
<p>Note: One should use the methods 'pre' or 'post' provided by <a class="el" href="a00123.html" title="Provides several utility methods for Mappings.">MappingUtils</a> to calculate the limit-time for the discontinuity.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The mapping the discontinuity will be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The position of the regular entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the regular entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limitTime</em>&nbsp;</td><td>The time-point of the limit-entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limitValue</em>&nbsp;</td><td>The value of the limit-entry. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00242_source.html#l00262">BaseMacLayer::createRectangleMapping()</a>.</p>

</div>
</div>
<a class="anchor" id="acca15c41da58e61619e67d1ec1538a9e"></a><!-- doxytag: member="MappingUtils::createMapping" ref="acca15c41da58e61619e67d1ec1538a9e" args="(Mapping::argument_value_cref_t outOfRangeValue, const DimensionSet &amp;domain=DimensionSet(Dimension::time), Mapping::InterpolationMethod intpl=Mapping::LINEAR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00121.html">Mapping</a> * MappingUtils::createMapping </td>
          <td>(</td>
          <td class="paramtype">Mapping::argument_value_cref_t&nbsp;</td>
          <td class="paramname"> <em>outOfRangeValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00083.html">DimensionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code><a class="el" href="a00083.html">DimensionSet</a>(<a class="el" href="a00082.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643">Mapping::InterpolationMethod</a>&nbsp;</td>
          <td class="paramname"> <em>intpl</em> = <code>Mapping::LINEAR</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an appropriate changeable <a class="el" href="a00121.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type...">Mapping</a> with the specified domain and the specified interpolation method. </p>
<p>Note: The interpolation method is always linear, at the moment. </p>

<p>Definition at line <a class="el" href="a00274_source.html#l00115">115</a> of file <a class="el" href="a00274_source.html">MappingUtils.cc</a>.</p>

<p>References <a class="el" href="a00273_source.html#l00305">DimensionSet::hasDimension()</a>, <a class="el" href="a00273_source.html#l01219">Mapping::LINEAR</a>, <a class="el" href="a00273_source.html#l01216">Mapping::NEAREST</a>, <a class="el" href="a00273_source.html#l00356">DimensionSet::size()</a>, <a class="el" href="a00273_source.html#l01214">Mapping::STEPS</a>, and <a class="el" href="a00273_source.html#l00080">Dimension::time</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00115"></a>00115                                                                                                                                              {
<a name="l00116"></a>00116   assert(domain.<a class="code" href="a00083.html#a015cb6fa6c77b26b8c7b1e65827b8342" title="Returns true if the passed Dimension is inside this DimensionSet.">hasDimension</a>(<a class="code" href="a00082.html#a16cb1f186dd3f48d33a4aebe948001d7" title="Shortcut to the time Dimension, same as &amp;#39;Dimension(&amp;quot;time&amp;quot;)&amp;#39;, but...">Dimension::time</a>));
<a name="l00117"></a>00117 
<a name="l00118"></a>00118   <span class="keywordflow">if</span>(domain.<a class="code" href="a00083.html#a0bf532a8e4cbf151337d24b7246790a9" title="Returns the size of the DimensionSet.">size</a>() == 1){
<a name="l00119"></a>00119     <span class="keywordflow">switch</span>(intpl){
<a name="l00120"></a>00120     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b" title="interpolates linear with next lower and next upper entry constant before the first...">Mapping::LINEAR</a>:
<a name="l00121"></a>00121       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00186.html">TimeMapping&lt;Linear&gt;</a>(outOfRangeVal);
<a name="l00122"></a>00122       <span class="keywordflow">break</span>;
<a name="l00123"></a>00123     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01" title="interpolates with nearest entry">Mapping::NEAREST</a>:
<a name="l00124"></a>00124       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00186.html" title="Implements the Mapping-interface with an InterpolateableMap from simtime_t to double...">TimeMapping&lt;Nearest&gt;</a>(outOfRangeVal);
<a name="l00125"></a>00125       <span class="keywordflow">break</span>;
<a name="l00126"></a>00126     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f" title="interpolates with next lower entry">Mapping::STEPS</a>:
<a name="l00127"></a>00127       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00186.html" title="Implements the Mapping-interface with an InterpolateableMap from simtime_t to double...">TimeMapping&lt;NextSmaller&gt;</a>(outOfRangeVal);
<a name="l00128"></a>00128       <span class="keywordflow">break</span>;
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130     <span class="keywordflow">return</span> 0;
<a name="l00131"></a>00131   } <span class="keywordflow">else</span> {
<a name="l00132"></a>00132     <span class="keywordflow">switch</span>(intpl){
<a name="l00133"></a>00133     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b" title="interpolates linear with next lower and next upper entry constant before the first...">Mapping::LINEAR</a>:
<a name="l00134"></a>00134       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00128.html">MultiDimMapping&lt;Linear&gt;</a>(domain, outOfRangeVal);
<a name="l00135"></a>00135       <span class="keywordflow">break</span>;
<a name="l00136"></a>00136     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01" title="interpolates with nearest entry">Mapping::NEAREST</a>:
<a name="l00137"></a>00137       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00128.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional...">MultiDimMapping&lt;Nearest&gt;</a>(domain, outOfRangeVal);
<a name="l00138"></a>00138       <span class="keywordflow">break</span>;
<a name="l00139"></a>00139     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f" title="interpolates with next lower entry">Mapping::STEPS</a>:
<a name="l00140"></a>00140       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00128.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional...">MultiDimMapping&lt;NextSmaller&gt;</a>(domain, outOfRangeVal);
<a name="l00141"></a>00141       <span class="keywordflow">break</span>;
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143     <span class="keywordflow">return</span> 0;
<a name="l00144"></a>00144   }
<a name="l00145"></a>00145 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0c61c76ba04339162563339b23bf42e9"></a><!-- doxytag: member="MappingUtils::createMapping" ref="a0c61c76ba04339162563339b23bf42e9" args="(const DimensionSet &amp;domain=DimensionSet(Dimension::time), Mapping::InterpolationMethod intpl=Mapping::LINEAR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00121.html">Mapping</a> * MappingUtils::createMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00083.html">DimensionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code><a class="el" href="a00083.html">DimensionSet</a>(<a class="el" href="a00082.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643">Mapping::InterpolationMethod</a>&nbsp;</td>
          <td class="paramname"> <em>intpl</em> = <code>Mapping::LINEAR</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an appropriate changeable <a class="el" href="a00121.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type...">Mapping</a> with the specified domain and the specified interpolation method. </p>
<p>Note: The interpolation method is always linear, at the moment. </p>

<p>Definition at line <a class="el" href="a00274_source.html#l00083">83</a> of file <a class="el" href="a00274_source.html">MappingUtils.cc</a>.</p>

<p>References <a class="el" href="a00273_source.html#l00305">DimensionSet::hasDimension()</a>, <a class="el" href="a00273_source.html#l01219">Mapping::LINEAR</a>, <a class="el" href="a00273_source.html#l01216">Mapping::NEAREST</a>, <a class="el" href="a00273_source.html#l00356">DimensionSet::size()</a>, <a class="el" href="a00273_source.html#l01214">Mapping::STEPS</a>, and <a class="el" href="a00273_source.html#l00080">Dimension::time</a>.</p>

<p>Referenced by <a class="el" href="a00257_source.html#l00250">BaseDecider::calculateRSSIMapping()</a>, <a class="el" href="a00242_source.html#l00242">BaseMacLayer::createConstantMapping()</a>, <a class="el" href="a00242_source.html#l00262">BaseMacLayer::createRectangleMapping()</a>, <a class="el" href="a00337_source.html#l01045">Mac80211::createSignal()</a>, <a class="el" href="a00242_source.html#l00280">BaseMacLayer::createSingleFrequencyMapping()</a>, <a class="el" href="a00303_source.html#l00031">LogNormalShadowing::filterSignal()</a>, <a class="el" href="a00206_source.html#l00010">RandomFrequencyOnlyModel::filterSignal()</a>, and <a class="el" href="a00204_source.html#l00009">RandomFreqTimeModel::filterSignal()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00083"></a>00083                                                                                                  {
<a name="l00084"></a>00084   assert(domain.<a class="code" href="a00083.html#a015cb6fa6c77b26b8c7b1e65827b8342" title="Returns true if the passed Dimension is inside this DimensionSet.">hasDimension</a>(<a class="code" href="a00082.html#a16cb1f186dd3f48d33a4aebe948001d7" title="Shortcut to the time Dimension, same as &amp;#39;Dimension(&amp;quot;time&amp;quot;)&amp;#39;, but...">Dimension::time</a>));
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="keywordflow">if</span>(domain.<a class="code" href="a00083.html#a0bf532a8e4cbf151337d24b7246790a9" title="Returns the size of the DimensionSet.">size</a>() == 1){
<a name="l00087"></a>00087     <span class="keywordflow">switch</span>(intpl){
<a name="l00088"></a>00088     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b" title="interpolates linear with next lower and next upper entry constant before the first...">Mapping::LINEAR</a>:
<a name="l00089"></a>00089       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00186.html">TimeMapping&lt;Linear&gt;</a>();
<a name="l00090"></a>00090       <span class="keywordflow">break</span>;
<a name="l00091"></a>00091     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01" title="interpolates with nearest entry">Mapping::NEAREST</a>:
<a name="l00092"></a>00092       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00186.html" title="Implements the Mapping-interface with an InterpolateableMap from simtime_t to double...">TimeMapping&lt;Nearest&gt;</a>();
<a name="l00093"></a>00093       <span class="keywordflow">break</span>;
<a name="l00094"></a>00094     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f" title="interpolates with next lower entry">Mapping::STEPS</a>:
<a name="l00095"></a>00095       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00186.html" title="Implements the Mapping-interface with an InterpolateableMap from simtime_t to double...">TimeMapping&lt;NextSmaller&gt;</a>();
<a name="l00096"></a>00096       <span class="keywordflow">break</span>;
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098     <span class="keywordflow">return</span> 0;
<a name="l00099"></a>00099   } <span class="keywordflow">else</span> {
<a name="l00100"></a>00100     <span class="keywordflow">switch</span>(intpl){
<a name="l00101"></a>00101     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b" title="interpolates linear with next lower and next upper entry constant before the first...">Mapping::LINEAR</a>:
<a name="l00102"></a>00102       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00128.html">MultiDimMapping&lt;Linear&gt;</a>(domain);
<a name="l00103"></a>00103       <span class="keywordflow">break</span>;
<a name="l00104"></a>00104     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01" title="interpolates with nearest entry">Mapping::NEAREST</a>:
<a name="l00105"></a>00105       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00128.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional...">MultiDimMapping&lt;Nearest&gt;</a>(domain);
<a name="l00106"></a>00106       <span class="keywordflow">break</span>;
<a name="l00107"></a>00107     <span class="keywordflow">case</span> <a class="code" href="a00121.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f" title="interpolates with next lower entry">Mapping::STEPS</a>:
<a name="l00108"></a>00108       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00128.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional...">MultiDimMapping&lt;NextSmaller&gt;</a>(domain);
<a name="l00109"></a>00109       <span class="keywordflow">break</span>;
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111     <span class="keywordflow">return</span> 0;
<a name="l00112"></a>00112   }
<a name="l00113"></a>00113 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac9d1a808dbca5da873af58f1da4cbcf4"></a><!-- doxytag: member="MappingUtils::findMax" ref="ac9d1a808dbca5da873af58f1da4cbcf4" args="(const ConstMapping &amp;m, const Argument &amp;min, const Argument &amp;max, Argument::mapped_type_cref cRetNotFound=cMaxNotFound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::argument_value_t MappingUtils::findMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00055.html">ConstMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00009.html">Argument</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00009.html">Argument</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&nbsp;</td>
          <td class="paramname"> <em>cRetNotFound</em> = <code><a class="el" href="a00123.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates over the passed mapping and returns the value at the key entry with the highest value in the range defined by the passed min and max parameter. </p>
<p>The area defined by the min and max parameter is the number of key entries which position in each dimension is bigger or equal than the value of the min parameter in that dimension and smaller or equal than max parameter in that dimension.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The map where the maximum value shall be searched. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min</em>&nbsp;</td><td>The beginning of search range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>The end of search range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cRetNotFound</em>&nbsp;</td><td>The value which shall be returned if no maximum was found (default <a class="el" href="a00123.html#a2a3f154e68d94b4b5a5ed580bb3e756f" title="The default value for findMax() functions if it does not find a maximum element.">MappingUtils::cMaxNotFound</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value at the key entry with the highest value or <code>cRetNotFound</code> if map is empty or no element in range [min,max]. </dd></dl>

<p>Definition at line <a class="el" href="a00274_source.html#l00232">232</a> of file <a class="el" href="a00274_source.html">MappingUtils.cc</a>.</p>

<p>References <a class="el" href="a00273_source.html#l00634">Argument::begin()</a>, <a class="el" href="a00055.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274">ConstMapping::createConstIterator()</a>, <a class="el" href="a00273_source.html#l00644">Argument::end()</a>, <a class="el" href="a00272_source.html#l00128">Argument::getArgValue()</a>, <a class="el" href="a00273_source.html#l00599">Argument::getDimensions()</a>, <a class="el" href="a00273_source.html#l00970">ConstMapping::getDimensionSet()</a>, <a class="el" href="a00272_source.html#l00090">Argument::getTime()</a>, and <a class="el" href="a00273_source.html#l00272">DimensionSet::isSubSet()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00232"></a>00232                                                                                                                                                                                   {
<a name="l00233"></a>00233   <span class="keyword">const</span> <a class="code" href="a00083.html" title="Represents a set of dimensions which is used to define over which dimensions a mapping...">DimensionSet</a>&amp; rDimSet = m.<a class="code" href="a00055.html#acc1559cf5741bec3aa6422e94c5b9cce" title="Returns this Mappings domain as DimensionSet.">getDimensionSet</a>();
<a name="l00234"></a>00234   <span class="comment">//the passed interval should define a value for every dimension</span>
<a name="l00235"></a>00235   <span class="comment">//of the mapping.</span>
<a name="l00236"></a>00236   assert(pRangeFrom.getDimensions().isSubSet(rDimSet));
<a name="l00237"></a>00237   assert(pRangeTo.getDimensions().isSubSet(rDimSet));
<a name="l00238"></a>00238 
<a name="l00239"></a>00239   <a class="code" href="a00056.html" title="Defines an const iterator for a ConstMapping which is able to iterate over the Mapping...">ConstMappingIterator</a>*     it       = m.<a class="code" href="a00055.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274" title="Returns a pointer of a new Iterator which is able to iterate over this Mapping.">createConstIterator</a>(pRangeFrom);
<a name="l00240"></a>00240   <span class="keywordtype">bool</span>                      bIsFirst = <span class="keyword">true</span>;
<a name="l00241"></a>00241   Mapping::argument_value_t res;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243   <span class="comment">//std::cerr &lt;&lt; &quot;findMax(m, &quot; &lt;&lt; pRangeFrom &lt;&lt; &quot;, &quot; &lt;&lt; pRangeTo &lt;&lt; &quot;): Map is&quot; &lt;&lt; std::endl &lt;&lt; m;</span>
<a name="l00244"></a>00244   <span class="keywordflow">if</span> (it-&gt;inRange()) {
<a name="l00245"></a>00245     res      = it-&gt;getValue();
<a name="l00246"></a>00246     bIsFirst = <span class="keyword">false</span>;
<a name="l00247"></a>00247     <span class="comment">//std::cerr &lt;&lt; &quot;findMax(...):  &quot; &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; max is at beginning: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
<a name="l00248"></a>00248   }
<a name="l00249"></a>00249   <span class="keywordflow">while</span>(it-&gt;hasNext() &amp;&amp; it-&gt;getNextPosition().compare(pRangeTo, &amp;rDimSet) &lt; 0){
<a name="l00250"></a>00250     it-&gt;next();
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="keyword">const</span> <a class="code" href="a00009.html" title="Defines an argument for a mapping.">Argument</a>&amp; next    = it-&gt;getPosition();
<a name="l00253"></a>00253     <span class="keywordtype">bool</span>            inRange = pRangeFrom.getTime() &lt;= next.<a class="code" href="a00009.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>() &amp;&amp; next.<a class="code" href="a00009.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>() &lt;= pRangeTo.getTime();
<a name="l00254"></a>00254     <span class="keywordflow">if</span>(inRange) {
<a name="l00255"></a>00255       <span class="keyword">const</span> <a class="code" href="a00009.html#a521abc97d737e8c77742dcc9f4b21022" title="Const-iterator type for this set.">Argument::const_iterator</a> itAEnd = next.<a class="code" href="a00009.html#aeeb6730c20ae8a8d6c9606f2e03cc1da" title="Returns an iterator to the value behind the last argument value.">end</a>();
<a name="l00256"></a>00256       <span class="keywordflow">for</span>(<a class="code" href="a00009.html#a521abc97d737e8c77742dcc9f4b21022" title="Const-iterator type for this set.">Argument::const_iterator</a> itA = next.<a class="code" href="a00009.html#af0e836fd4aaecc1461b994e21f66ddc3" title="Returns an iterator to the first argument value in this Argument.">begin</a>(); itA != itAEnd; ++itA) {
<a name="l00257"></a>00257         <span class="keywordflow">if</span>(pRangeFrom.getArgValue(itA-&gt;first) &gt; itA-&gt;second || itA-&gt;second &gt; pRangeTo.getArgValue(itA-&gt;first)) {
<a name="l00258"></a>00258           inRange = <span class="keyword">false</span>;
<a name="l00259"></a>00259           <span class="keywordflow">break</span>;
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261       }
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263     <span class="keywordflow">if</span>(inRange) {
<a name="l00264"></a>00264       Mapping::argument_value_cref_t val = it-&gt;getValue();
<a name="l00265"></a>00265       <span class="keywordflow">if</span>(bIsFirst || val &gt; res) {
<a name="l00266"></a>00266         res      = val;
<a name="l00267"></a>00267         bIsFirst = <span class="keyword">false</span>;
<a name="l00268"></a>00268       }
<a name="l00269"></a>00269       <span class="comment">//std::cerr &lt;&lt; &quot;findMax(...): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; max is now: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
<a name="l00270"></a>00270     }
<a name="l00271"></a>00271   }
<a name="l00272"></a>00272   it-&gt;iterateTo(pRangeTo);
<a name="l00273"></a>00273   <span class="keywordflow">if</span> (it-&gt;inRange()) {
<a name="l00274"></a>00274     Mapping::argument_value_cref_t val = it-&gt;getValue();
<a name="l00275"></a>00275     <span class="keywordflow">if</span>(bIsFirst || val &gt; res) {
<a name="l00276"></a>00276       res      = val;
<a name="l00277"></a>00277       bIsFirst = <span class="keyword">false</span>;
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279     <span class="comment">//std::cerr &lt;&lt; &quot;findMax(...): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; max is finally: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
<a name="l00280"></a>00280   }
<a name="l00281"></a>00281   <span class="keyword">delete</span> it;
<a name="l00282"></a>00282   <span class="keywordflow">if</span> (bIsFirst) {
<a name="l00283"></a>00283     <span class="comment">// no minimum available</span>
<a name="l00284"></a>00284     <span class="keywordflow">return</span> cRetNotFound;
<a name="l00285"></a>00285   }
<a name="l00286"></a>00286   <span class="keywordflow">return</span> res;
<a name="l00287"></a>00287 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afbe1a1e1d2becd66d2c0d5a8ac42b478"></a><!-- doxytag: member="MappingUtils::findMax" ref="afbe1a1e1d2becd66d2c0d5a8ac42b478" args="(const ConstMapping &amp;m, Argument::mapped_type_cref cRetNotFound=cMaxNotFound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::argument_value_t MappingUtils::findMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00055.html">ConstMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&nbsp;</td>
          <td class="paramname"> <em>cRetNotFound</em> = <code><a class="el" href="a00123.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates over the passed mapping and returns value at the key entry with the highest value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The map where the maximum value shall be searched. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cRetNotFound</em>&nbsp;</td><td>The value which shall be returned if no maximum was found (default <a class="el" href="a00123.html#a2a3f154e68d94b4b5a5ed580bb3e756f" title="The default value for findMax() functions if it does not find a maximum element.">MappingUtils::cMaxNotFound</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value at the key entry with the highest value or <code>cRetNotFound</code> if map is empty. </dd></dl>

<p>Definition at line <a class="el" href="a00274_source.html#l00206">206</a> of file <a class="el" href="a00274_source.html">MappingUtils.cc</a>.</p>

<p>References <a class="el" href="a00055.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274">ConstMapping::createConstIterator()</a>, <a class="el" href="a00056.html#ad4419c259e747867f003d07d62d4259f">ConstMappingIterator::getValue()</a>, <a class="el" href="a00056.html#ad4bac7233c154b7086c6124d2e21be49">ConstMappingIterator::hasNext()</a>, <a class="el" href="a00056.html#a4a6348a453418da95978e570fec046fc">ConstMappingIterator::inRange()</a>, and <a class="el" href="a00056.html#afdafa6870cd19b3d35674a7bc777585d">ConstMappingIterator::next()</a>.</p>

<p>Referenced by <a class="el" href="a00389_source.html#l00076">Decider80211::calcChannelSenseRSSI()</a>, and <a class="el" href="a00257_source.html#l00198">BaseDecider::calcChannelSenseRSSI()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00206"></a>00206                                                                                                                              {
<a name="l00207"></a>00207   <a class="code" href="a00056.html" title="Defines an const iterator for a ConstMapping which is able to iterate over the Mapping...">ConstMappingIterator</a>*     it       = m.<a class="code" href="a00055.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274" title="Returns a pointer of a new Iterator which is able to iterate over this Mapping.">createConstIterator</a>();
<a name="l00208"></a>00208   <span class="keywordtype">bool</span>                      bIsFirst = <span class="keyword">true</span>;
<a name="l00209"></a>00209   Mapping::argument_value_t res;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211   <span class="keywordflow">while</span>(it-&gt;<a class="code" href="a00056.html#a4a6348a453418da95978e570fec046fc" title="Returns true if the current position of the iterator is in range of the function...">inRange</a>()){
<a name="l00212"></a>00212     Mapping::argument_value_cref_t val = it-&gt;<a class="code" href="a00056.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
<a name="l00213"></a>00213     <span class="keywordflow">if</span>(bIsFirst || val &gt; res) {
<a name="l00214"></a>00214       res      = val;
<a name="l00215"></a>00215       bIsFirst = <span class="keyword">false</span>;
<a name="l00216"></a>00216     }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218     <span class="comment">//std::cerr &lt;&lt; &quot;findMax(): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; max is now: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
<a name="l00219"></a>00219     <span class="keywordflow">if</span>(!it-&gt;<a class="code" href="a00056.html#ad4bac7233c154b7086c6124d2e21be49" title="Returns true if the iterator has a next value it can iterate to on a call to &amp;quot;next()&amp;quot;...">hasNext</a>())
<a name="l00220"></a>00220       <span class="keywordflow">break</span>;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222     it-&gt;<a class="code" href="a00056.html#afdafa6870cd19b3d35674a7bc777585d" title="Iterates to the next position of the Mapping.">next</a>();
<a name="l00223"></a>00223   }
<a name="l00224"></a>00224   <span class="keyword">delete</span> it;
<a name="l00225"></a>00225   <span class="keywordflow">if</span> (bIsFirst) {
<a name="l00226"></a>00226     <span class="comment">// no maximum available, maybe map is empty</span>
<a name="l00227"></a>00227     <span class="keywordflow">return</span> cRetNotFound;
<a name="l00228"></a>00228   }
<a name="l00229"></a>00229   <span class="keywordflow">return</span> res;
<a name="l00230"></a>00230 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="adb9e9ced268b9a5d1d4f6d34738654aa"></a><!-- doxytag: member="MappingUtils::findMin" ref="adb9e9ced268b9a5d1d4f6d34738654aa" args="(const ConstMapping &amp;m, const Argument &amp;min, const Argument &amp;max, Argument::mapped_type_cref cRetNotFound=cMinNotFound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::argument_value_t MappingUtils::findMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00055.html">ConstMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00009.html">Argument</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00009.html">Argument</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&nbsp;</td>
          <td class="paramname"> <em>cRetNotFound</em> = <code><a class="el" href="a00123.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates over the passed mapping and returns the value at the key entry with the smallest value in the range defined by the passed min and max parameter. </p>
<p>The area defined by the min and max parameter is the number of key entries which position in each dimension is bigger or equal than the value of the min parameter in that dimension and smaller or equal than max parameter in that dimension.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The map where the minimum value shall be searched. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min</em>&nbsp;</td><td>The beginning of search range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>The end of search range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cRetNotFound</em>&nbsp;</td><td>The value which shall be returned if no minimum was found (default <a class="el" href="a00123.html#a3db893e8948a5af5fe947fb0740d86ca" title="The default value for findMin() functions if it does not find a minimum element.">MappingUtils::cMinNotFound</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value at the key entry with the highest value or <code>cRetNotFound</code> if map is empty or no element in range [min,max]. </dd></dl>

<p>Definition at line <a class="el" href="a00274_source.html#l00315">315</a> of file <a class="el" href="a00274_source.html">MappingUtils.cc</a>.</p>

<p>References <a class="el" href="a00273_source.html#l00634">Argument::begin()</a>, <a class="el" href="a00272_source.html#l00262">Argument::compare()</a>, <a class="el" href="a00055.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274">ConstMapping::createConstIterator()</a>, <a class="el" href="a00273_source.html#l00644">Argument::end()</a>, <a class="el" href="a00272_source.html#l00128">Argument::getArgValue()</a>, <a class="el" href="a00273_source.html#l00599">Argument::getDimensions()</a>, <a class="el" href="a00273_source.html#l00970">ConstMapping::getDimensionSet()</a>, <a class="el" href="a00056.html#a1f4cae3b170754a76049b8e81b2e3c07">ConstMappingIterator::getNextPosition()</a>, <a class="el" href="a00056.html#a047e853613d5a19ff34526d0cff8fcf9">ConstMappingIterator::getPosition()</a>, <a class="el" href="a00272_source.html#l00090">Argument::getTime()</a>, <a class="el" href="a00056.html#ad4419c259e747867f003d07d62d4259f">ConstMappingIterator::getValue()</a>, <a class="el" href="a00056.html#ad4bac7233c154b7086c6124d2e21be49">ConstMappingIterator::hasNext()</a>, <a class="el" href="a00056.html#a4a6348a453418da95978e570fec046fc">ConstMappingIterator::inRange()</a>, <a class="el" href="a00273_source.html#l00272">DimensionSet::isSubSet()</a>, <a class="el" href="a00056.html#a607d741e2d841265851a85670f247c46">ConstMappingIterator::iterateTo()</a>, and <a class="el" href="a00056.html#afdafa6870cd19b3d35674a7bc777585d">ConstMappingIterator::next()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00315"></a>00315                                                                                                                                                                                    {
<a name="l00316"></a>00316   <span class="keyword">const</span> <a class="code" href="a00083.html" title="Represents a set of dimensions which is used to define over which dimensions a mapping...">DimensionSet</a>&amp; rDimSet = m.<a class="code" href="a00055.html#acc1559cf5741bec3aa6422e94c5b9cce" title="Returns this Mappings domain as DimensionSet.">getDimensionSet</a>();
<a name="l00317"></a>00317   <span class="comment">//the passed interval should define a value for every dimension</span>
<a name="l00318"></a>00318   <span class="comment">//of the mapping.</span>
<a name="l00319"></a>00319   assert(pRangeFrom.getDimensions().isSubSet(rDimSet));
<a name="l00320"></a>00320   assert(pRangeTo.getDimensions().isSubSet(rDimSet));
<a name="l00321"></a>00321 
<a name="l00322"></a>00322   Mapping::argument_value_t res;
<a name="l00323"></a>00323   <span class="keywordtype">bool</span>                      bIsFirst = <span class="keyword">true</span>;
<a name="l00324"></a>00324   <a class="code" href="a00056.html" title="Defines an const iterator for a ConstMapping which is able to iterate over the Mapping...">ConstMappingIterator</a>*     it       = m.<a class="code" href="a00055.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274" title="Returns a pointer of a new Iterator which is able to iterate over this Mapping.">createConstIterator</a>(pRangeFrom);
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="comment">//std::cerr &lt;&lt; &quot;findMin(m, &quot; &lt;&lt; pRangeFrom &lt;&lt; &quot;, &quot; &lt;&lt; pRangeTo &lt;&lt; &quot;): Map is&quot; &lt;&lt; std::endl &lt;&lt; m;</span>
<a name="l00327"></a>00327   <span class="keywordflow">if</span> (it-&gt;<a class="code" href="a00056.html#a4a6348a453418da95978e570fec046fc" title="Returns true if the current position of the iterator is in range of the function...">inRange</a>()) {
<a name="l00328"></a>00328     res      = it-&gt;<a class="code" href="a00056.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
<a name="l00329"></a>00329     bIsFirst = <span class="keyword">false</span>;
<a name="l00330"></a>00330     <span class="comment">//std::cerr &lt;&lt; &quot;findMin(...):  &quot; &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; min is at beginning: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
<a name="l00331"></a>00331   }
<a name="l00332"></a>00332   <span class="keywordflow">while</span>(it-&gt;<a class="code" href="a00056.html#ad4bac7233c154b7086c6124d2e21be49" title="Returns true if the iterator has a next value it can iterate to on a call to &amp;quot;next()&amp;quot;...">hasNext</a>() &amp;&amp; it-&gt;<a class="code" href="a00056.html#a1f4cae3b170754a76049b8e81b2e3c07" title="Returns the position the next call to &amp;quot;next()&amp;quot; of this Iterator would iterate...">getNextPosition</a>().<a class="code" href="a00009.html#ac983761168238481be2bc9d9d180abe5" title="Compares this Argument with the passed Argument in the dimensions of the passed DimensionsSet...">compare</a>(pRangeTo, &amp;rDimSet) &lt; 0) {
<a name="l00333"></a>00333     it-&gt;<a class="code" href="a00056.html#afdafa6870cd19b3d35674a7bc777585d" title="Iterates to the next position of the Mapping.">next</a>();
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="keyword">const</span> <a class="code" href="a00009.html" title="Defines an argument for a mapping.">Argument</a>&amp; next    = it-&gt;<a class="code" href="a00056.html#a047e853613d5a19ff34526d0cff8fcf9" title="Returns the current position of the iterator.">getPosition</a>();
<a name="l00336"></a>00336     <span class="keywordtype">bool</span>            inRange = pRangeFrom.<a class="code" href="a00009.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>() &lt;= next.<a class="code" href="a00009.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>()  &amp;&amp; next.<a class="code" href="a00009.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>() &lt;= pRangeTo.getTime();
<a name="l00337"></a>00337     <span class="keywordflow">if</span>(inRange) {
<a name="l00338"></a>00338       <span class="keyword">const</span> <a class="code" href="a00009.html#a521abc97d737e8c77742dcc9f4b21022" title="Const-iterator type for this set.">Argument::const_iterator</a> itAEnd = next.<a class="code" href="a00009.html#aeeb6730c20ae8a8d6c9606f2e03cc1da" title="Returns an iterator to the value behind the last argument value.">end</a>();
<a name="l00339"></a>00339       <span class="keywordflow">for</span>(<a class="code" href="a00009.html#a521abc97d737e8c77742dcc9f4b21022" title="Const-iterator type for this set.">Argument::const_iterator</a> itA = next.<a class="code" href="a00009.html#af0e836fd4aaecc1461b994e21f66ddc3" title="Returns an iterator to the first argument value in this Argument.">begin</a>(); itA != itAEnd; ++itA) {
<a name="l00340"></a>00340         <span class="keywordflow">if</span>(pRangeFrom.getArgValue(itA-&gt;first) &gt; itA-&gt;second || itA-&gt;second &gt; pRangeTo.getArgValue(itA-&gt;first)) {
<a name="l00341"></a>00341           inRange = <span class="keyword">false</span>;
<a name="l00342"></a>00342           <span class="keywordflow">break</span>;
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344       }
<a name="l00345"></a>00345     }
<a name="l00346"></a>00346     <span class="keywordflow">if</span>(inRange) {
<a name="l00347"></a>00347       Mapping::argument_value_cref_t val = it-&gt;<a class="code" href="a00056.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
<a name="l00348"></a>00348       <span class="keywordflow">if</span>(bIsFirst || val &lt; res) {
<a name="l00349"></a>00349         res      = val;
<a name="l00350"></a>00350         bIsFirst = <span class="keyword">false</span>;
<a name="l00351"></a>00351       }
<a name="l00352"></a>00352       <span class="comment">//std::cerr &lt;&lt; &quot;findMin(...): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; min is now: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
<a name="l00353"></a>00353     }
<a name="l00354"></a>00354   }
<a name="l00355"></a>00355   it-&gt;<a class="code" href="a00056.html#a607d741e2d841265851a85670f247c46" title="Iterates to the specified position. This method should be used if the new position...">iterateTo</a>(pRangeTo);
<a name="l00356"></a>00356   <span class="keywordflow">if</span> (it-&gt;<a class="code" href="a00056.html#a4a6348a453418da95978e570fec046fc" title="Returns true if the current position of the iterator is in range of the function...">inRange</a>()) {
<a name="l00357"></a>00357     Mapping::argument_value_cref_t val = it-&gt;<a class="code" href="a00056.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
<a name="l00358"></a>00358     <span class="keywordflow">if</span>(bIsFirst || val &lt; res) {
<a name="l00359"></a>00359       res      = val;
<a name="l00360"></a>00360       bIsFirst = <span class="keyword">false</span>;
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362     <span class="comment">//std::cerr &lt;&lt; &quot;findMin(...): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; min is finally: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
<a name="l00363"></a>00363   }
<a name="l00364"></a>00364   <span class="keyword">delete</span> it;
<a name="l00365"></a>00365   <span class="keywordflow">if</span> (bIsFirst) {
<a name="l00366"></a>00366     <span class="comment">// no minimum available</span>
<a name="l00367"></a>00367     <span class="keywordflow">return</span> cRetNotFound;
<a name="l00368"></a>00368   }
<a name="l00369"></a>00369   <span class="keywordflow">return</span> res;
<a name="l00370"></a>00370 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5d9c4e3dcaddccfa65f21212d0fee2cf"></a><!-- doxytag: member="MappingUtils::findMin" ref="a5d9c4e3dcaddccfa65f21212d0fee2cf" args="(const ConstMapping &amp;m, Argument::mapped_type_cref cRetNotFound=cMinNotFound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::argument_value_t MappingUtils::findMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00055.html">ConstMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&nbsp;</td>
          <td class="paramname"> <em>cRetNotFound</em> = <code><a class="el" href="a00123.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates over the passed mapping and returns value at the key entry with the smallest value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The map where the minimum value shall be searched. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cRetNotFound</em>&nbsp;</td><td>The value which shall be returned if no minimum was found (default <a class="el" href="a00123.html#a3db893e8948a5af5fe947fb0740d86ca" title="The default value for findMin() functions if it does not find a minimum element.">MappingUtils::cMinNotFound</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value at the key entry with the lowest value or <code>cRetNotFound</code> if map is empty. </dd></dl>

<p>Definition at line <a class="el" href="a00274_source.html#l00289">289</a> of file <a class="el" href="a00274_source.html">MappingUtils.cc</a>.</p>

<p>References <a class="el" href="a00055.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274">ConstMapping::createConstIterator()</a>, <a class="el" href="a00056.html#ad4419c259e747867f003d07d62d4259f">ConstMappingIterator::getValue()</a>, <a class="el" href="a00056.html#ad4bac7233c154b7086c6124d2e21be49">ConstMappingIterator::hasNext()</a>, <a class="el" href="a00056.html#a4a6348a453418da95978e570fec046fc">ConstMappingIterator::inRange()</a>, and <a class="el" href="a00056.html#afdafa6870cd19b3d35674a7bc777585d">ConstMappingIterator::next()</a>.</p>

<p>Referenced by <a class="el" href="a00389_source.html#l00093">Decider80211::checkIfSignalOk()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00289"></a>00289                                                                                                                              {
<a name="l00290"></a>00290   <a class="code" href="a00056.html" title="Defines an const iterator for a ConstMapping which is able to iterate over the Mapping...">ConstMappingIterator</a>*     it       = m.<a class="code" href="a00055.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274" title="Returns a pointer of a new Iterator which is able to iterate over this Mapping.">createConstIterator</a>();
<a name="l00291"></a>00291   <span class="keywordtype">bool</span>                      bIsFirst = <span class="keyword">true</span>;
<a name="l00292"></a>00292   Mapping::argument_value_t res;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294   <span class="keywordflow">while</span>(it-&gt;<a class="code" href="a00056.html#a4a6348a453418da95978e570fec046fc" title="Returns true if the current position of the iterator is in range of the function...">inRange</a>()) {
<a name="l00295"></a>00295     Mapping::argument_value_cref_t val = it-&gt;<a class="code" href="a00056.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
<a name="l00296"></a>00296     <span class="keywordflow">if</span>(bIsFirst || val &lt; res) {
<a name="l00297"></a>00297       res      = val;
<a name="l00298"></a>00298       bIsFirst = <span class="keyword">false</span>;
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301     <span class="comment">//std::cerr &lt;&lt; &quot;findMin(): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; min is now: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
<a name="l00302"></a>00302     <span class="keywordflow">if</span>(!it-&gt;<a class="code" href="a00056.html#ad4bac7233c154b7086c6124d2e21be49" title="Returns true if the iterator has a next value it can iterate to on a call to &amp;quot;next()&amp;quot;...">hasNext</a>())
<a name="l00303"></a>00303       <span class="keywordflow">break</span>;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     it-&gt;<a class="code" href="a00056.html#afdafa6870cd19b3d35674a7bc777585d" title="Iterates to the next position of the Mapping.">next</a>();
<a name="l00306"></a>00306   }
<a name="l00307"></a>00307   <span class="keyword">delete</span> it;
<a name="l00308"></a>00308   <span class="keywordflow">if</span> (bIsFirst) {
<a name="l00309"></a>00309     <span class="comment">// no minimum available, maybe map is empty</span>
<a name="l00310"></a>00310     <span class="keywordflow">return</span> cRetNotFound;
<a name="l00311"></a>00311   }
<a name="l00312"></a>00312   <span class="keywordflow">return</span> res;
<a name="l00313"></a>00313 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a11550dc6dc55beb5a14def9ffb501a40"></a><!-- doxytag: member="MappingUtils::multiply" ref="a11550dc6dc55beb5a14def9ffb501a40" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00121.html">Mapping</a> * MappingUtils::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00055.html">ConstMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00055.html">ConstMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies the passed functions element-wise with each other and returns the result in a new Function. </p>
<p>The domain (<a class="el" href="a00083.html" title="Represents a set of dimensions which is used to define over which dimensions a mapping...">DimensionSet</a>) of the result is defined by the domain of the first operand. The domain of the second <a class="el" href="a00121.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type...">Mapping</a> has to be a subset of the domain of the first mapping. </p>

<p>Definition at line <a class="el" href="a00274_source.html#l00147">147</a> of file <a class="el" href="a00274_source.html">MappingUtils.cc</a>.</p>

<p>Referenced by <a class="el" href="a00212_source.html#l00067">ThresholdDecider::handleSignalOver()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00148"></a>00148 {
<a name="l00149"></a>00149   <span class="keywordflow">return</span> applyElementWiseOperator(f1, f2, std::multiplies&lt;Mapping::argument_value_t&gt;());
<a name="l00150"></a>00150 }
</pre></div></p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2a3f154e68d94b4b5a5ed580bb3e756f"></a><!-- doxytag: member="MappingUtils::cMaxNotFound" ref="a2a3f154e68d94b4b5a5ed580bb3e756f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Argument::mapped_type <a class="el" href="a00123.html#a2a3f154e68d94b4b5a5ed580bb3e756f">MappingUtils::cMaxNotFound</a> = -std::numeric_limits&lt;Argument::mapped_type&gt;::infinity()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default value for <a class="el" href="a00123.html#afbe1a1e1d2becd66d2c0d5a8ac42b478" title="Iterates over the passed mapping and returns value at the key entry with the highest...">findMax()</a> functions if it does not find a maximum element. </p>
<p>It will be initialized with the negative infinity value. </p>

<p>Definition at line <a class="el" href="a00275_source.html#l01810">1810</a> of file <a class="el" href="a00275_source.html">MappingUtils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3db893e8948a5af5fe947fb0740d86ca"></a><!-- doxytag: member="MappingUtils::cMinNotFound" ref="a3db893e8948a5af5fe947fb0740d86ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Argument::mapped_type <a class="el" href="a00123.html#a3db893e8948a5af5fe947fb0740d86ca">MappingUtils::cMinNotFound</a> = std::numeric_limits&lt;Argument::mapped_type&gt;::infinity()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default value for <a class="el" href="a00123.html#a5d9c4e3dcaddccfa65f21212d0fee2cf" title="Iterates over the passed mapping and returns value at the key entry with the smallest...">findMin()</a> functions if it does not find a minimum element. </p>
<p>It will be initialized with the infinity value. </p>

<p>Definition at line <a class="el" href="a00275_source.html#l01805">1805</a> of file <a class="el" href="a00275_source.html">MappingUtils.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/base/phyLayer/<a class="el" href="a00275_source.html">MappingUtils.h</a></li>
<li>src/base/phyLayer/<a class="el" href="a00274_source.html">MappingUtils.cc</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Dec 14 16:01:50 2011 for MiXiM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
