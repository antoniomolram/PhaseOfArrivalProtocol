<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: ConstInterpolateableIterator&lt; _Interpolator, _IteratorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ConstInterpolateableIterator&lt; _Interpolator, _IteratorType &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00455.html">mappingDetails - mostly internal mapping classes</a>]</small>
</h1><!-- doxytag: class="ConstInterpolateableIterator" -->
<p>Template for an interpolateable const iterator for any container which maps from a key to a value. This doesn't necessarily has to be a map, but also can be a sorted list of pairs.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00268_source.html">Interpolation.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ConstInterpolateableIterator&lt; _Interpolator, _IteratorType &gt;:</div>
<div class="dynsection">
<div class="center"><img src="a00561.png" border="0" usemap="#ConstInterpolateableIterator_3_01__Interpolator_00_01__IteratorType_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a00562.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ceb4238f825dc152217058c0c7dc001"></a><!-- doxytag: member="ConstInterpolateableIterator::interpolator_type" ref="a1ceb4238f825dc152217058c0c7dc001" args="" -->
typedef _Interpolator&nbsp;</td><td class="memItemRight" valign="bottom"><b>interpolator_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50b68c37524eff1e40fc9b9977476e7d"></a><!-- doxytag: member="ConstInterpolateableIterator::container_type" ref="a50b68c37524eff1e40fc9b9977476e7d" args="" -->
typedef <br class="typebreak"/>
interpolator_type::container_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>container_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad73c5dcc647fa3b7a84763a954fe11bb"></a><!-- doxytag: member="ConstInterpolateableIterator::key_type" ref="ad73c5dcc647fa3b7a84763a954fe11bb" args="" -->
typedef interpolator_type::key_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c972215632186ddedcda88204012353"></a><!-- doxytag: member="ConstInterpolateableIterator::key_cref_type" ref="a2c972215632186ddedcda88204012353" args="" -->
typedef <br class="typebreak"/>
interpolator_type::key_cref_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>key_cref_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d498cb8110907ecc04a5a9a005db9ed"></a><!-- doxytag: member="ConstInterpolateableIterator::mapped_type" ref="a0d498cb8110907ecc04a5a9a005db9ed" args="" -->
typedef <br class="typebreak"/>
interpolator_type::mapped_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c3a2627837864de9aa91b7a8ba4c815"></a><!-- doxytag: member="ConstInterpolateableIterator::mapped_cref_type" ref="a5c3a2627837864de9aa91b7a8ba4c815" args="" -->
typedef <br class="typebreak"/>
interpolator_type::mapped_cref_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapped_cref_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11cdbe76ac12b7479f1c4697131f6dd1"></a><!-- doxytag: member="ConstInterpolateableIterator::pair_type" ref="a11cdbe76ac12b7479f1c4697131f6dd1" args="" -->
typedef <br class="typebreak"/>
interpolator_type::pair_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>pair_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a524823dbf762366cded5cfe2ccca2939"></a><!-- doxytag: member="ConstInterpolateableIterator::iterator" ref="a524823dbf762366cded5cfe2ccca2939" args="" -->
typedef interpolator_type::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7539b5f9b0b46a26a33d1f1c22845084"></a><!-- doxytag: member="ConstInterpolateableIterator::const_iterator" ref="a7539b5f9b0b46a26a33d1f1c22845084" args="" -->
typedef <br class="typebreak"/>
interpolator_type::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7de2ff003436372e26b57596da13b8c3"></a><!-- doxytag: member="ConstInterpolateableIterator::comparator_type" ref="a7de2ff003436372e26b57596da13b8c3" args="" -->
typedef <br class="typebreak"/>
interpolator_type::comparator_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>comparator_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad651c523db58df483cb6a3369406ef22"></a><!-- doxytag: member="ConstInterpolateableIterator::used_iterator" ref="ad651c523db58df483cb6a3369406ef22" args="" -->
typedef _IteratorType&nbsp;</td><td class="memItemRight" valign="bottom"><b>used_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ed1c02edab5e7153ef4d29f26e57216"></a><!-- doxytag: member="ConstInterpolateableIterator::interpolated" ref="a5ed1c02edab5e7153ef4d29f26e57216" args="" -->
typedef <br class="typebreak"/>
interpolator_type::interpolated&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a5ed1c02edab5e7153ef4d29f26e57216">interpolated</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">typedef for the returned <a class="el" href="a00099.html" title="Represents an interpolated value of any type.">Interpolated</a> value of this class. <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7376c0555d5afa5e51e5fef70d32d2b"></a><!-- doxytag: member="ConstInterpolateableIterator::ConstInterpolateableIterator" ref="af7376c0555d5afa5e51e5fef70d32d2b" args="(const used_iterator &amp;first, const used_iterator &amp;last, const interpolator_type &amp;intpl)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#af7376c0555d5afa5e51e5fef70d32d2b">ConstInterpolateableIterator</a> (const used_iterator &amp;first, const used_iterator &amp;last, const interpolator_type &amp;intpl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the iterator with the passed Iterators as boundaries. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cbe300c6f575e24a8ab9ab269cac8ff"></a><!-- doxytag: member="ConstInterpolateableIterator::operator==" ref="a4cbe300c6f575e24a8ab9ab269cac8ff" args="(const ConstInterpolateableIterator &amp;other)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00054.html">ConstInterpolateableIterator</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad149b5c37b429ccc1fc5615c217cd3de"></a><!-- doxytag: member="ConstInterpolateableIterator::jumpTo" ref="ad149b5c37b429ccc1fc5615c217cd3de" args="(key_cref_type pos)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#ad149b5c37b429ccc1fc5615c217cd3de">jumpTo</a> (key_cref_type pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the iterator to the passed position. This position can be any value of the Key-type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a812d4bd2ab7b419deb933b8c472e1912"></a><!-- doxytag: member="ConstInterpolateableIterator::jumpToBegin" ref="a812d4bd2ab7b419deb933b8c472e1912" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a812d4bd2ab7b419deb933b8c472e1912">jumpToBegin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the iterator to the first element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a0a190c448a5cfbcd3385c6ccd316542f">iterateTo</a> (key_cref_type pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">forward iterates the iterator to the passed position. This position can be any value of the Key-type.  <a href="#a0a190c448a5cfbcd3385c6ccd316542f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#aa9b9aaf1491ef6ef251bc7399aecdf52">next</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates to the next entry in the underlying data structure.  <a href="#aa9b9aaf1491ef6ef251bc7399aecdf52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa545c5da980cbc9a5889ac6cf42d7b7e"></a><!-- doxytag: member="ConstInterpolateableIterator::getNextPosition" ref="aa545c5da980cbc9a5889ac6cf42d7b7e" args="()" -->
key_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>getNextPosition</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eca971338ae67b5ee34503cbcf1f342"></a><!-- doxytag: member="ConstInterpolateableIterator::inRange" ref="a4eca971338ae67b5ee34503cbcf1f342" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a4eca971338ae67b5ee34503cbcf1f342">inRange</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the current position of the iterator is between the position of the first and the last entry of the data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4906a4e7a03086a28d108fc262faa969"></a><!-- doxytag: member="ConstInterpolateableIterator::hasNext" ref="a4906a4e7a03086a28d108fc262faa969" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a4906a4e7a03086a28d108fc262faa969">hasNext</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the a call of "next()" would increase to the position of an a valid entry of the data structure. This means if the current position is smaller than position of the last entry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html#a5ed1c02edab5e7153ef4d29f26e57216">interpolated</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#afd052facfd07e1a139a6da76d129917e">getValue</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the interpolated value at the current position of the Iterator.  <a href="#afd052facfd07e1a139a6da76d129917e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca4c6576c12ffd03107960a356e76326"></a><!-- doxytag: member="ConstInterpolateableIterator::getNextValue" ref="aca4c6576c12ffd03107960a356e76326" args="() const " -->
<a class="el" href="a00054.html#a5ed1c02edab5e7153ef4d29f26e57216">interpolated</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getNextValue</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8b162ab907fbc33e47db214f28518a"></a><!-- doxytag: member="ConstInterpolateableIterator::getPosition" ref="a2d8b162ab907fbc33e47db214f28518a" args="() const " -->
key_cref_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a2d8b162ab907fbc33e47db214f28518a">getPosition</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current position of the iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e45b990b544290f7a0dd1a8155c4978"></a><!-- doxytag: member="ConstInterpolateableIterator::getInterpolator" ref="a9e45b990b544290f7a0dd1a8155c4978" args="() const " -->
const interpolator_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>getInterpolator</b> () const </td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3720bcb63a64de42e4b16cb86df2bb77"></a><!-- doxytag: member="ConstInterpolateableIterator::first" ref="a3720bcb63a64de42e4b16cb86df2bb77" args="" -->
used_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>first</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15720a496cb3f3942707583ef80db5a2"></a><!-- doxytag: member="ConstInterpolateableIterator::last" ref="a15720a496cb3f3942707583ef80db5a2" args="" -->
used_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>last</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bb5e64387644bd21ca8345e15f5bcd1"></a><!-- doxytag: member="ConstInterpolateableIterator::right" ref="a4bb5e64387644bd21ca8345e15f5bcd1" args="" -->
used_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>right</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22d17fb7ce4b73648b28e62b34292382"></a><!-- doxytag: member="ConstInterpolateableIterator::position" ref="a22d17fb7ce4b73648b28e62b34292382" args="" -->
key_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>position</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac41169286738eeb6ef050a87eb1ced3"></a><!-- doxytag: member="ConstInterpolateableIterator::interpolate" ref="aac41169286738eeb6ef050a87eb1ced3" args="" -->
const interpolator_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>interpolate</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename _Interpolator, typename _IteratorType = typename _Interpolator::const_iterator&gt;<br/>
 class ConstInterpolateableIterator&lt; _Interpolator, _IteratorType &gt;</h3>

<p>Template for an interpolateable const iterator for any container which maps from a key to a value. This doesn't necessarily has to be a map, but also can be a sorted list of pairs. </p>
<p>The <a class="el" href="a00054.html" title="Template for an interpolateable const iterator for any container which maps from...">ConstInterpolateableIterator</a> provides an iterator which as able to iterate in arbitrary steps over a iterateable number of pairs of "Key" and "Value". To determine the Value for a Key which does not exist in within the iterateable number of pairs it Interpolates between the nearby existing pairs. The actual Interpolation is determined by the passed Interpolator-template parameter.</p>
<p>An example use would be to be able to iterate over a std::map&lt;double, double&gt; in arbitrary steps (even at positions for which no Key exist inside the map) and be able to return an interpolated Value.</p>
<p>NOTE: The <a class="el" href="a00054.html" title="Template for an interpolateable const iterator for any container which maps from...">ConstInterpolateableIterator</a> will become invalid if the underlying data structure is changed!</p>
<p>Template parameters: Pair - the type of the pair used as values in the container. Default is std::map&lt;Key, V&gt;::value_type (which is of type std::pair&lt;Key, V&gt;. The Pair type has to provide the two public members "first" and "second". Key - The type of the "first" member of the Pair type V - the type of the "second" member of the Pair type Iterator - the type of the iterator of the container (should be a const iterator). Default is std::map&lt;Key, V&gt;::const_iterator Interpolator - The Interpolation operator to use, this has to be a class which overwrites the ()-operator with the following parameters: <a class="el" href="a00099.html" title="Represents an interpolated value of any type.">Interpolated</a> operator()(const Iterator&amp; first, const Iterator&amp; last, const Key&amp; pos) <a class="el" href="a00099.html" title="Represents an interpolated value of any type.">Interpolated</a> operator()(const Iterator&amp; first, const Iterator&amp; last, const Key&amp; pos, Iterator upperBound) See the <a class="el" href="a00138.html" title="Given two iterators defining a range of key-value-pairs this class provides interpolation...">NextSmaller</a> template for an example of an Interpolator. Default is NextSmaller&lt;Key, V, Pair, Iterator&gt;.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Karl Wessel </dd></dl>

<p>Definition at line <a class="el" href="a00268_source.html#l00541">541</a> of file <a class="el" href="a00268_source.html">Interpolation.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afd052facfd07e1a139a6da76d129917e"></a><!-- doxytag: member="ConstInterpolateableIterator::getValue" ref="afd052facfd07e1a139a6da76d129917e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Interpolator, typename _IteratorType = typename _Interpolator::const_iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html#a5ed1c02edab5e7153ef4d29f26e57216">interpolated</a> <a class="el" href="a00054.html">ConstInterpolateableIterator</a>&lt; _Interpolator, _IteratorType &gt;::getValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the interpolated value at the current position of the Iterator. </p>
<p>See definition of <a class="el" href="a00099.html" title="Represents an interpolated value of any type.">Interpolated</a> on details on the return type. </p>

<p>Definition at line <a class="el" href="a00268_source.html#l00676">676</a> of file <a class="el" href="a00268_source.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00275_source.html#l01122">MultiDimMappingIterator&lt; Linear &gt;::MultiDimMappingIterator()</a>, and <a class="el" href="a00275_source.html#l01039">MultiDimMappingIterator&lt; Linear &gt;::updateSubIterator()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00676"></a>00676                                {
<a name="l00677"></a>00677     <span class="keywordflow">return</span> interpolate(first, last, position, right);
<a name="l00678"></a>00678   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0a190c448a5cfbcd3385c6ccd316542f"></a><!-- doxytag: member="ConstInterpolateableIterator::iterateTo" ref="a0a190c448a5cfbcd3385c6ccd316542f" args="(key_cref_type pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Interpolator, typename _IteratorType = typename _Interpolator::const_iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00054.html">ConstInterpolateableIterator</a>&lt; _Interpolator, _IteratorType &gt;::iterateTo </td>
          <td>(</td>
          <td class="paramtype">key_cref_type&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>forward iterates the iterator to the passed position. This position can be any value of the Key-type. </p>
<p>This method assumes that the passed position is near the current position of the iterator. If this is the case this method will be faster than the jumpTo-method. </p>

<p>Definition at line <a class="el" href="a00268_source.html#l00616">616</a> of file <a class="el" href="a00268_source.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00275_source.html#l01216">MultiDimMappingIterator&lt; Linear &gt;::iterateTo()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00616"></a>00616                                     {
<a name="l00617"></a>00617     <span class="keywordflow">if</span>(pos == position)
<a name="l00618"></a>00618       <span class="keywordflow">return</span>;
<a name="l00619"></a>00619 
<a name="l00620"></a>00620     <span class="keywordflow">while</span>(right != last &amp;&amp; !(pos &lt; right-&gt;first))
<a name="l00621"></a>00621       ++right;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623     position = pos;
<a name="l00624"></a>00624   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa9b9aaf1491ef6ef251bc7399aecdf52"></a><!-- doxytag: member="ConstInterpolateableIterator::next" ref="aa9b9aaf1491ef6ef251bc7399aecdf52" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Interpolator, typename _IteratorType = typename _Interpolator::const_iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00054.html">ConstInterpolateableIterator</a>&lt; _Interpolator, _IteratorType &gt;::next </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates to the next entry in the underlying data structure. </p>
<p>If the current position is before the position of the first element of the data structure this method will iterate to the first entry. If the current position is after the position of the last element of the data structure this method will increase the current position with the ++ operator. </p>

<p>Definition at line <a class="el" href="a00268_source.html#l00634">634</a> of file <a class="el" href="a00268_source.html">Interpolation.h</a>.</p>

<p>Referenced by <a class="el" href="a00275_source.html#l01243">MultiDimMappingIterator&lt; Linear &gt;::next()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00634"></a>00634               {
<a name="l00635"></a>00635     <span class="keywordflow">if</span>(<a class="code" href="a00054.html#a4906a4e7a03086a28d108fc262faa969" title="Returns true if the a call of &amp;quot;next()&amp;quot; would increase to the position of...">hasNext</a>()) {
<a name="l00636"></a>00636       position = right-&gt;first;
<a name="l00637"></a>00637       ++right;
<a name="l00638"></a>00638     } <span class="keywordflow">else</span>
<a name="l00639"></a>00639       position += 1;
<a name="l00640"></a>00640   }
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/base/phyLayer/<a class="el" href="a00268_source.html">Interpolation.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Dec 14 16:01:49 2011 for MiXiM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
